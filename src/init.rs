/* automatically generated by rust-bindgen 0.59.2 */

pub const vnc_true: u32 = 1;
pub const vnc_false: u32 = 0;
pub const vnc_success: u32 = 1;
pub const vnc_failure: u32 = 0;
pub const VNC_SDK_MAJOR_VERSION: u32 = 1;
pub const VNC_SDK_MINOR_VERSION: u32 = 9;
pub const VNC_SDK_PATCH_VERSION: u32 = 1;
pub const VNC_SDK_BUILD_NUMBER: u32 = 46075;
pub type vnc_int8_t = ::std::os::raw::c_schar;
pub type vnc_int16_t = ::std::os::raw::c_short;
pub type vnc_int32_t = ::std::os::raw::c_int;
pub type vnc_int64_t = ::std::os::raw::c_longlong;
pub type vnc_uint8_t = ::std::os::raw::c_uchar;
pub type vnc_uint16_t = ::std::os::raw::c_ushort;
pub type vnc_uint31_t = ::std::os::raw::c_uint;
pub type vnc_uint32_t = ::std::os::raw::c_uint;
pub type vnc_uint64_t = ::std::os::raw::c_ulonglong;
pub type vnc_bool_t = ::std::os::raw::c_int;
pub type vnc_status_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Connection {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_ConnectionHandler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_AnnotationManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_MessagingManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DisplayManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DataBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Server {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Viewer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_PixelFormat {
    _unused: [u8; 0],
}
pub type vnc_assert_int8_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int16_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int32_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int64_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint8_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint16_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint31_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint32_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint64_t = [::std::os::raw::c_char; 1usize];
pub const vnc_DummyEnum_vnc_DummyEnum1: vnc_DummyEnum = 0;
pub const vnc_DummyEnum_vnc_DummyEnum2: vnc_DummyEnum = 1;
pub type vnc_DummyEnum = ::std::os::raw::c_uint;
pub type vnc_assert_DummyEnum = [::std::os::raw::c_char; 1usize];
pub type VncAssertionHandler =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;

#[doc = " The default event loop is a Windows event loop on Windows, a"]
#[doc = " file-descriptor event loop on Linux, a Core Foundation event loop on OS X"]
#[doc = " and iOS, and an Android event loop on Android.  There is no event loop in"]
#[doc = " HTML5."]
pub const vnc_EventLoopType_vnc_EventLoopType_Default: vnc_EventLoopType = 0;
#[doc = " The Windows event loop is only available on Windows."]
pub const vnc_EventLoopType_vnc_EventLoopType_Win: vnc_EventLoopType = 1;
#[doc = " The file-descriptor event loop is available on Linux, OS X, iOS, and"]
#[doc = " Android."]
pub const vnc_EventLoopType_vnc_EventLoopType_Fd: vnc_EventLoopType = 2;
#[doc = " The Core Foundation event loop is available on OS X and iOS."]
pub const vnc_EventLoopType_vnc_EventLoopType_Cf: vnc_EventLoopType = 3;
#[doc = " The Android \"Looper\" event loop is only available on Android."]
pub const vnc_EventLoopType_vnc_EventLoopType_Android: vnc_EventLoopType = 4;
#[doc = " Enumeration of types of event loop used by the SDK."]
pub type vnc_EventLoopType = ::std::os::raw::c_uint;
extern "C" {
    pub fn vnc_shutdown() -> vnc_status_t;
    pub fn vnc_initInternal(
        majorVersion: ::std::os::raw::c_int,
        minorVersion: ::std::os::raw::c_int,
        patchVersion: ::std::os::raw::c_int,
        buildNumber: ::std::os::raw::c_int,
        eventLoopType: vnc_EventLoopType,
    ) -> vnc_status_t;
    pub fn vnc_setAssertionHandlerInternal(handler: VncAssertionHandler) -> VncAssertionHandler;
    pub fn vnc_getBuildNumber() -> ::std::os::raw::c_int;
    pub fn vnc_getPatchVersion() -> ::std::os::raw::c_int;
    pub fn vnc_getMinorVersion() -> ::std::os::raw::c_int;
    pub fn vnc_getMajorVersion() -> ::std::os::raw::c_int;
}
