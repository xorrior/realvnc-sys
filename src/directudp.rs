/* automatically generated by rust-bindgen 0.59.2 */

pub const vnc_true: u32 = 1;
pub const vnc_false: u32 = 0;
pub const vnc_success: u32 = 1;
pub const vnc_failure: u32 = 0;
pub const VNC_DIRECT_UDP_DEFAULT_PORT: u32 = 5900;
#[doc = " @name Common primitive types */"]
pub type vnc_int8_t = ::std::os::raw::c_schar;
pub type vnc_int16_t = ::std::os::raw::c_short;
pub type vnc_int32_t = ::std::os::raw::c_int;
pub type vnc_int64_t = ::std::os::raw::c_longlong;
pub type vnc_uint8_t = ::std::os::raw::c_uchar;
pub type vnc_uint16_t = ::std::os::raw::c_ushort;
pub type vnc_uint31_t = ::std::os::raw::c_uint;
pub type vnc_uint32_t = ::std::os::raw::c_uint;
pub type vnc_uint64_t = ::std::os::raw::c_ulonglong;
#[doc = " @name Boolean type"]
#[doc = " @details Note that #vnc_true and #vnc_false are guaranteed to be defined as"]
#[doc = " 1 and 0 respectively in all future versions of the SDK.  There is no need to"]
#[doc = " explicitly reference these constants, unless you prefer that coding style."]
pub type vnc_bool_t = ::std::os::raw::c_int;
#[doc = " @name Status type"]
#[doc = " @details Note that #vnc_success and #vnc_failure are guaranteed to be defined"]
#[doc = " as 1 and 0 respectively in all future versions of the SDK.  There is no need"]
#[doc = " to explicitly reference these constants, unless you prefer that coding style;"]
#[doc = " either of these is acceptable:"]
#[doc = ""]
#[doc = " @code"]
#[doc = " if (!vnc_Logger_createFileLogger(\"logfile.txt\"))"]
#[doc = "     handleError();"]
#[doc = " @endcode"]
#[doc = ""]
#[doc = " or:"]
#[doc = " @code"]
#[doc = " if (vnc_Logger_createFileLogger(\"logfile.txt\") != vnc_success)"]
#[doc = "     handleError();"]
#[doc = " @endcode"]
#[doc = ""]
pub type vnc_status_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Connection {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_ConnectionHandler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_AnnotationManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_MessagingManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DisplayManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DataBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Server {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Viewer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_PixelFormat {
    _unused: [u8; 0],
}
pub type vnc_assert_int8_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int16_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int32_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int64_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint8_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint16_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint31_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint32_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint64_t = [::std::os::raw::c_char; 1usize];
pub const vnc_DummyEnum_vnc_DummyEnum1: vnc_DummyEnum = 0;
pub const vnc_DummyEnum_vnc_DummyEnum2: vnc_DummyEnum = 1;
pub type vnc_DummyEnum = ::std::os::raw::c_uint;
pub type vnc_assert_DummyEnum = [::std::os::raw::c_char; 1usize];
pub type VncAssertionHandler =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DirectUdpListener {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DirectUdpConnector {
    _unused: [u8; 0],
}
#[doc = " Callback for filtering incoming UDP connections."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DirectUdpListener_Callback {
    #[doc = " Notification to provide address-based filtering of incoming connections."]
    #[doc = " This callback is optional."]
    #[doc = ""]
    #[doc = " @param listener The listening object that performed this callback."]
    #[doc = " @param ipAddress The IP address of the remote end that is attempting to"]
    #[doc = "     make a connection. The address is presented in a human-readable form"]
    #[doc = "     such as 122.16.224.1 (IPv4) and 2001:dc8:0:1534:0:867:6:1 (IPv6)"]
    #[doc = " @param port The port on which a connection is being attempted."]
    #[doc = ""]
    #[doc = " @return #vnc_true to allow the connection, or #vnc_false to deny, in which"]
    #[doc = "     case the connection will be closed."]
    #[doc = ""]
    #[doc = " @since 1.8 XXX"]
    pub filterConnection: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            listener: *mut vnc_DirectUdpListener,
            ipAddress: *const ::std::os::raw::c_char,
            port: ::std::os::raw::c_int,
        ) -> vnc_bool_t,
    >,
}
#[test]
fn bindgen_test_layout_vnc_DirectUdpListener_Callback() {
    assert_eq!(
        ::std::mem::size_of::<vnc_DirectUdpListener_Callback>(),
        8usize,
        concat!("Size of: ", stringify!(vnc_DirectUdpListener_Callback))
    );
    assert_eq!(
        ::std::mem::align_of::<vnc_DirectUdpListener_Callback>(),
        8usize,
        concat!("Alignment of ", stringify!(vnc_DirectUdpListener_Callback))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_DirectUdpListener_Callback>())).filterConnection as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_DirectUdpListener_Callback),
            "::",
            stringify!(filterConnection)
        )
    );
}

extern "C" {
    #[doc = " Begins an outgoing UDP connection to the given hostname or IP address.  The"]
    #[doc = " connection will be handled by the supplied @p connectionHandler."]
    #[doc = ""]
    #[doc = " Connection errors are notified using the server or viewer's callbacks"]
    #[doc = " (depending on the type of the connection handler used). This includes errors"]
    #[doc = " arising when resolving a specified hostname."]
    #[doc = ""]
    #[doc = " @param connector The UDP connector that is to begin the connection."]
    #[doc = " @param hostOrIpAddress The DNS hostname or IP address to connect to."]
    #[doc = " @param port The port number to connect to. Note: The default port for VNC"]
    #[doc = "     connections can be obtained using @ref VNC_DIRECT_UDP_DEFAULT_PORT"]
    #[doc = " @param connectionHandler The object (a Viewer or a Server) to handle the"]
    #[doc = "     connection."]
    #[doc = ""]
    #[doc = " @return #vnc_success is returned on success or #vnc_failure in the case of"]
    #[doc = "     an error, in which case vnc_getLastError() can be used to get the error"]
    #[doc = "     code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     @p port is invalid, or"]
    #[doc = "     @p connectionHandler is a null pointer"]
    #[doc = ""]
    #[doc = " @since 1.8 XXX"]
    pub fn vnc_DirectUdpConnector_connect(
        connector: *mut vnc_DirectUdpConnector,
        hostOrIpAddress: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_int,
        connectionHandler: *mut vnc_ConnectionHandler,
    ) -> vnc_status_t;
    #[doc = " Destroys the UDP Connector."]
    #[doc = ""]
    #[doc = " @param connector The UDP connector to destroy."]
    #[doc = ""]
    #[doc = " @since 1.8 XXX"]
    pub fn vnc_DirectUdpConnector_destroy(connector: *mut vnc_DirectUdpConnector);
    #[doc = " Creates a new UDP Connector which is used to make outgoing connections"]
    #[doc = "     to UDP listeners."]
    #[doc = ""]
    #[doc = " @return Returns a new UDP Connector on success, or NULL in the case of an"]
    #[doc = "     error, in which case vnc_getLastError() can be used to get the error"]
    #[doc = "     code."]
    #[doc = ""]
    #[doc = " @retval NotEnabled"]
    #[doc = "     The SDK does not have the Direct UDP add-on enabled"]
    #[doc = ""]
    #[doc = " @since 1.8 XXX"]
    pub fn vnc_DirectUdpConnector_create() -> *mut vnc_DirectUdpConnector;
    #[doc = " Destroys the UDP listener.  Any ongoing connections are not affected, but"]
    #[doc = " new connections will not be accepted."]
    #[doc = ""]
    #[doc = " @param listener The UDP listener to destroy."]
    #[doc = ""]
    #[doc = " @since 1.8 XXX"]
    pub fn vnc_DirectUdpListener_destroy(listener: *mut vnc_DirectUdpListener);
    #[doc = " Begin listening for incoming UDP connections on the given port (IPv4 and"]
    #[doc = " IPv6).  To stop listening, destroy the UDP listener."]
    #[doc = ""]
    #[doc = " @param port The port number to listen on."]
    #[doc = " @param addressList A comma-separated list of addresses to listen on. If"]
    #[doc = "     empty or null then listening starts on all addresses."]
    #[doc = " @param connectionHandler The object which shall handle incoming connections"]
    #[doc = "     (if not rejected by the filter function).  It is either a server or a"]
    #[doc = "     viewer.  It must be destroyed after the UDP listener."]
    #[doc = " @param callback An optional callback to filter incoming connections."]
    #[doc = " @param userData An optional pointer to user data."]
    #[doc = ""]
    #[doc = " @return Returns a new UDP listener on success, or NULL in the case of an"]
    #[doc = "     error, in which case vnc_getLastError() can be used to get the error"]
    #[doc = "     code."]
    #[doc = ""]
    #[doc = " @retval AddressError"]
    #[doc = "     There was an error listening on the specified address"]
    #[doc = " @retval NotEnabled"]
    #[doc = "     The SDK does not have the Direct UDP add-on enabled"]
    #[doc = ""]
    #[doc = " @since 1.8 XXX"]
    pub fn vnc_DirectUdpListener_create(
        port: ::std::os::raw::c_int,
        addressList: *const ::std::os::raw::c_char,
        connectionHandler: *mut vnc_ConnectionHandler,
        callback: *const vnc_DirectUdpListener_Callback,
        userData: *mut ::std::os::raw::c_void,
    ) -> *mut vnc_DirectUdpListener;
}
