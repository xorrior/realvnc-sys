/* automatically generated by rust-bindgen 0.59.2 */

pub const vnc_true: u32 = 1;
pub const vnc_false: u32 = 0;
pub const vnc_success: u32 = 1;
pub const vnc_failure: u32 = 0;
#[doc = " @name Common primitive types */"]
pub type vnc_int8_t = ::std::os::raw::c_schar;
pub type vnc_int16_t = ::std::os::raw::c_short;
pub type vnc_int32_t = ::std::os::raw::c_int;
pub type vnc_int64_t = ::std::os::raw::c_longlong;
pub type vnc_uint8_t = ::std::os::raw::c_uchar;
pub type vnc_uint16_t = ::std::os::raw::c_ushort;
pub type vnc_uint31_t = ::std::os::raw::c_uint;
pub type vnc_uint32_t = ::std::os::raw::c_uint;
pub type vnc_uint64_t = ::std::os::raw::c_ulonglong;
pub type vnc_bool_t = ::std::os::raw::c_int;

pub type vnc_status_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Connection {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_ConnectionHandler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_AnnotationManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_MessagingManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DisplayManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DataBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Server {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Viewer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_PixelFormat {
    _unused: [u8; 0],
}
pub type vnc_assert_int8_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int16_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int32_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int64_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint8_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint16_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint31_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint32_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint64_t = [::std::os::raw::c_char; 1usize];
pub const vnc_DummyEnum_vnc_DummyEnum1: vnc_DummyEnum = 0;
pub const vnc_DummyEnum_vnc_DummyEnum2: vnc_DummyEnum = 1;
pub type vnc_DummyEnum = ::std::os::raw::c_uint;
pub type vnc_assert_DummyEnum = [::std::os::raw::c_char; 1usize];
pub type VncAssertionHandler =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_CloudListener {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_CloudConnector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_CloudAddressMonitor {
    _unused: [u8; 0],
}
#[doc = " The listener is in the process of establishing an association with VNC"]
#[doc = " Cloud.  Incoming connections are not yet possible."]
pub const vnc_CloudListener_Status_vnc_CloudListener_StatusSearching: vnc_CloudListener_Status = 0;
#[doc = " The listener is available for incoming connections."]
pub const vnc_CloudListener_Status_vnc_CloudListener_StatusOnline: vnc_CloudListener_Status = 1;
#[doc = " Enumeration of listening statuses."]
pub type vnc_CloudListener_Status = ::std::os::raw::c_uint;
#[doc = " Callback for a @ref vnc_CloudListener."]
#[doc = ""]
#[doc = " @see vnc_CloudListener_create()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_CloudListener_Callback {
    #[doc = " Notification that the Cloud listener has stopped listening and is unable"]
    #[doc = " to accept any more connections.  This callback is required."]
    #[doc = ""]
    #[doc = " The Cloud listener internally handles errors due to transient networking"]
    #[doc = " conditions, but if a connection to VNC Cloud cannot be promptly"]
    #[doc = " re-established, the Cloud listener stops, leaving the application to choose"]
    #[doc = " whether to retry or to present an error message to the user.  In a"]
    #[doc = " long-running application where the user may not be present, it is normal to"]
    #[doc = " retry wherever possible; in a short-lived \"helpdesk\" application it may be"]
    #[doc = " desirable not to retry at all when there are errors but simply present a"]
    #[doc = " message to the user."]
    #[doc = ""]
    #[doc = " Some errors are unrecoverable, such as invalid Cloud credentials, and in"]
    #[doc = " this case the user must be notified rather than creating a new Cloud"]
    #[doc = " listener using the same credentials.  In this case, @p retryTimeSecs is"]
    #[doc = " -1."]
    #[doc = ""]
    #[doc = " For recoverable errors (such as a lack of network connectivity), is is"]
    #[doc = " possible to retry listening.  This is done by destroying the Cloud"]
    #[doc = " listener, then creating a new one after a delay.  The delay should not be"]
    #[doc = " too short, or excessive bandwidth and needless load on the VNC Cloud will"]
    #[doc = " be generated.  The @p retryTimeSecs parameter indicates a safe delay to"]
    #[doc = " use, starting at five seconds and gradually increasing to a maximum"]
    #[doc = " with each failure.  Do not retry more rapidly than indicated by"]
    #[doc = " @p retryTimeSecs, or service may be impaired for other users of VNC Cloud"]
    #[doc = " at times of peak load."]
    #[doc = ""]
    #[doc = " @param cloudError A specific error string describing the cause.  Possible"]
    #[doc = "     errors are: @c CloudAuthenticationFailed, @c CloudConnectivityError."]
    #[doc = " @param retryTimeSecs The time in seconds to wait before attempting to"]
    #[doc = "     listen again using this Cloud address, or -1 if the error is fatal"]
    #[doc = "     and automatic recovery after a delay is not possible."]
    pub listeningFailed: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            listener: *mut vnc_CloudListener,
            cloudError: *const ::std::os::raw::c_char,
            retryTimeSecs: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Notification to provide address-based filtering of incoming connections."]
    #[doc = " This callback is optional."]
    #[doc = ""]
    #[doc = " @param peerCloudAddress The address of the peer requesting a connection."]
    #[doc = ""]
    #[doc = " @return #vnc_true to allow the connection, or #vnc_false to deny, in"]
    #[doc = "     which case the connection will be closed."]
    pub filterConnection: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            listener: *mut vnc_CloudListener,
            peerCloudAddress: *const ::std::os::raw::c_char,
        ) -> vnc_bool_t,
    >,
    #[doc = " Notification that the listener status has changed.  This callback is"]
    #[doc = " optional."]
    #[doc = ""]
    #[doc = " After creating a listener, it is initially unable to receive connections"]
    #[doc = " until it has successfully checked-in with VNC Cloud.  If network"]
    #[doc = " connectivity is temporarily lost, the status can also change from"]
    #[doc = " @ref vnc_CloudListener_StatusOnline back to"]
    #[doc = " @ref vnc_CloudListener_StatusSearching."]
    #[doc = ""]
    #[doc = " @param status The new status of the Cloud listener."]
    pub listeningStatusChanged: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            listener: *mut vnc_CloudListener,
            status: vnc_CloudListener_Status,
        ),
    >,
}
#[test]
fn bindgen_test_layout_vnc_CloudListener_Callback() {
    assert_eq!(
        ::std::mem::size_of::<vnc_CloudListener_Callback>(),
        24usize,
        concat!("Size of: ", stringify!(vnc_CloudListener_Callback))
    );
    assert_eq!(
        ::std::mem::align_of::<vnc_CloudListener_Callback>(),
        8usize,
        concat!("Alignment of ", stringify!(vnc_CloudListener_Callback))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_CloudListener_Callback>())).listeningFailed as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_CloudListener_Callback),
            "::",
            stringify!(listeningFailed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_CloudListener_Callback>())).filterConnection as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_CloudListener_Callback),
            "::",
            stringify!(filterConnection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_CloudListener_Callback>())).listeningStatusChanged
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_CloudListener_Callback),
            "::",
            stringify!(listeningStatusChanged)
        )
    );
}
extern "C" {
    #[doc = " Begins listening for incoming connections on the given Cloud address.  To"]
    #[doc = " stop listening, destroy the Cloud listener."]
    #[doc = ""]
    #[doc = " The Cloud listener's status is initially"]
    #[doc = " @ref vnc_CloudListener_StatusSearching while it is locating a nearby Cloud"]
    #[doc = " server to use, then changes to @ref vnc_CloudListener_StatusOnline once it is"]
    #[doc = " ready to receive connections; when this happens the"]
    #[doc = " vnc_CloudListener_Callback::listeningStatusChanged function is called.  It is"]
    #[doc = " also possible for the listener to briefly switch back to"]
    #[doc = " @ref vnc_CloudListener_StatusSearching during normal operation."]
    #[doc = ""]
    #[doc = " If an error occurs, then the listener reaches a terminal error state; when"]
    #[doc = " this happens, the vnc_CloudListener_Callback::listeningFailed function"]
    #[doc = " is called and the vnc_CloudListener_Callback::listeningStatusChanged function"]
    #[doc = " is not notified.  The only thing that can be done after an error is to"]
    #[doc = " destroy the listener and create a new one after a delay."]
    #[doc = ""]
    #[doc = " @param localCloudAddress The cloud address on which to listen for incoming"]
    #[doc = "     connections (typically a string with four components of the form"]
    #[doc = "     <tt>XXX.XXX.XXX.XXX</tt>)."]
    #[doc = " @param localCloudPassword The password associated with @p localCloudAddress"]
    #[doc = "     (typically a short alphanumeric string)."]
    #[doc = " @param connectionHandler The object which shall handle incoming connections"]
    #[doc = "     (if not rejected by the filter function).  It is either a server or a"]
    #[doc = "     viewer.  It must be destroyed after the Cloud listener."]
    #[doc = " @param callback The callback is required, in order to receive notification of"]
    #[doc = "     errors."]
    #[doc = ""]
    #[doc = " @return Returns a new @ref vnc_CloudListener on success, or NULL on error."]
    #[doc = "     If an error is returned, vnc_getLastError() can be used to get the error"]
    #[doc = "     code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     The given Cloud address and password are malformed"]
    #[doc = " @retval AddressError"]
    #[doc = "     The given Cloud address is not valid or is already in use"]
    pub fn vnc_CloudListener_create(
        localCloudAddress: *const ::std::os::raw::c_char,
        localCloudPassword: *const ::std::os::raw::c_char,
        connectionHandler: *mut vnc_ConnectionHandler,
        callback: *const vnc_CloudListener_Callback,
        userData: *mut ::std::os::raw::c_void,
    ) -> *mut vnc_CloudListener;

    #[doc = " Destroys the Cloud listener.  Any ongoing connections are not affected, but"]
    #[doc = " new connections will not be accepted."]
    #[doc = ""]
    #[doc = " @param listener The listener."]
    pub fn vnc_CloudListener_destroy(listener: *mut vnc_CloudListener);
    #[doc = " Creates a connector, which is used used to create connections to Cloud"]
    #[doc = " addresses."]
    #[doc = ""]
    #[doc = " @param localCloudAddress The cloud address representing our end for outgoing"]
    #[doc = "     connections (typically a string with four components of the form"]
    #[doc = "     <tt>XXX.XXX.XXX.XXX</tt>)."]
    #[doc = " @param localCloudPassword The password associated with @p localCloudAddress"]
    #[doc = "     (typically a short alphanumeric string)."]
    #[doc = ""]
    #[doc = " @return Returns a new @ref vnc_CloudConnector on success, or NULL on error."]
    #[doc = "     If an error is returned, vnc_getLastError() can be used to get the error"]
    #[doc = "     code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     The given Cloud address or password is malformed"]
    #[doc = " @retval AddressError"]
    #[doc = "     The given Cloud address is not valid or is already in use"]
    pub fn vnc_CloudConnector_create(
        localCloudAddress: *const ::std::os::raw::c_char,
        localCloudPassword: *const ::std::os::raw::c_char,
    ) -> *mut vnc_CloudConnector;
    #[doc = " Destroys the Cloud connector."]
    #[doc = ""]
    #[doc = " @param connector The connector."]
    pub fn vnc_CloudConnector_destroy(connector: *mut vnc_CloudConnector);
    #[doc = " Begins an outgoing connection to the given Cloud address.  The connection"]
    #[doc = " will be handled by the @p connectionHandler."]
    #[doc = ""]
    #[doc = " The Cloud connector can be used to create connections to any number of"]
    #[doc = " different peer addresses, without having to wait for earlier connections to"]
    #[doc = " finish (note however that a viewer cannot be used as a connection handler if"]
    #[doc = " it is already connected).  Two simultaneous connections to the same peer"]
    #[doc = " Cloud address are not supported.  The connector can be destroyed immediately"]
    #[doc = " after creating a connection, without affecting the connection: the connection"]
    #[doc = " handler immediately takes ownership of it."]
    #[doc = ""]
    #[doc = " Connection errors are notified using the server or viewer's callbacks"]
    #[doc = " (depending on the type of the connection handler)."]
    #[doc = ""]
    #[doc = " @param connector The connector."]
    #[doc = " @param peerCloudAddress The cloud address to make a connection to."]
    #[doc = " @param connectionHandler The object which shall handle the outgoing"]
    #[doc = "     connection.  It is either a server or a viewer.  Connection errors are"]
    #[doc = "     notified via the connection handler's callbacks."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     The given Cloud address or password is malformed"]
    #[doc = " @retval UnexpectedCall"]
    #[doc = "     The connection handler is already connected"]
    pub fn vnc_CloudConnector_connect(
        connector: *mut vnc_CloudConnector,
        peerCloudAddress: *const ::std::os::raw::c_char,
        connectionHandler: *mut vnc_ConnectionHandler,
    ) -> vnc_status_t;
    #[doc = " Sets whether new connections created by the connector wait for the peer to"]
    #[doc = " start listening.  The default behaviour is for connections to fail if the"]
    #[doc = " peer is not currently listening."]
    #[doc = ""]
    #[doc = " @param connector The connector."]
    #[doc = " @param waitForPeer If set to #vnc_true, then the connection attempt will"]
    #[doc = "     wait for the peer to create a Cloud listener.  The application must"]
    #[doc = "     decide how long to wait, and cancel the connection attempt after a"]
    #[doc = "     suitable timeout by destroying the viewer."]
    pub fn vnc_CloudConnector_setWaitForPeer(
        connector: *mut vnc_CloudConnector,
        waitForPeer: vnc_bool_t,
    );

    #[doc = " Set the bandwidth limit applied to relayed Cloud connections."]
    #[doc = ""]
    #[doc = " Connections made via VNC Cloud are either @em direct or @em relayed.  A"]
    #[doc = " direct connection will be made where possible, but if one of the peers is"]
    #[doc = " behind a restrictive NAT or firewall, then VNC Cloud will be used to relay"]
    #[doc = " the data.  In this case, a bandwidth limit may be set to control use of the"]
    #[doc = " relay."]
    #[doc = ""]
    #[doc = " After calling vnc_CloudConnector_create(), the connector's initial bandwidth"]
    #[doc = " limit is unlimited.  If a new limit is set on the connector, it will be"]
    #[doc = " applied to all subsequent connections started using"]
    #[doc = " vnc_CloudConnector_connect()."]
    #[doc = ""]
    #[doc = " @param relayBandwidthLimit The limit in bytes per second, or -1 for"]
    #[doc = "     unlimited.  The allowed values are in the range 1024 to 999999999."]
    #[doc = ""]
    #[doc = " @return @c vnc_success is returned on success or @c vnc_failure in the case"]
    #[doc = "     of an error, in which case vnc_getLastError() can be used to get the"]
    #[doc = "     error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     The bandwidth limit is out of range"]
    pub fn vnc_CloudConnector_setRelayBandwidthLimit(
        connector: *mut vnc_CloudConnector,
        relayBandwidthLimit: ::std::os::raw::c_int,
    ) -> vnc_status_t;

    #[doc = " Creates a monitor, which queries whether a list of cloud addresses is"]
    #[doc = " available.  (An address is \"available\" if there is a Cloud listener currently"]
    #[doc = " accepting connections on that address.)  The monitor will notify its"]
    #[doc = " callback whenever the availability information for an address is updated."]
    #[doc = ""]
    #[doc = " Each Cloud connector can have at most one associated monitor at one time."]
    #[doc = ""]
    #[doc = " @param connector The connector used by the monitor for queries to VNC Cloud."]
    #[doc = " @param cloudAddresses An array of cloud addresses to be monitored."]
    #[doc = " @param nAddresses The length of the @p cloudAddresses array."]
    #[doc = " @param callback The required callback for receiving availability information."]
    #[doc = ""]
    #[doc = " @return Returns a new @ref vnc_CloudAddressMonitor on success, or NULL on"]
    #[doc = "     error.  If an error is returned, vnc_getLastError() can be used to get"]
    #[doc = "     the error code."]
    #[doc = ""]
    #[doc = " @retval UnexpectedCall"]
    #[doc = "     The given Cloud connector already has a monitor"]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     One of the given Cloud addresses is malformed"]
    pub fn vnc_CloudAddressMonitor_create(
        connector: *mut vnc_CloudConnector,
        cloudAddresses: *mut *const ::std::os::raw::c_char,
        nAddresses: ::std::os::raw::c_int,
        callback: *const vnc_CloudAddressMonitor_Callback,
        userData: *mut ::std::os::raw::c_void,
    ) -> *mut vnc_CloudAddressMonitor;

    #[doc = " Destroys the Cloud monitor."]
    #[doc = ""]
    #[doc = " @param monitor The monitor."]
    pub fn vnc_CloudAddressMonitor_destroy(monitor: *mut vnc_CloudAddressMonitor);
    #[doc = " Pauses the Cloud monitor.  While paused, updates will not be fetched for"]
    #[doc = " the peer addresses, however, the callback may still be notified of changes in"]
    #[doc = " availability for a short while after pausing.  If a list of cloud addresses"]
    #[doc = " is being shown with their availabilities, it would be appropriate to pause"]
    #[doc = " the monitor while the window is not focused, for example."]
    #[doc = ""]
    #[doc = " @param monitor The monitor."]
    pub fn vnc_CloudAddressMonitor_pause(monitor: *mut vnc_CloudAddressMonitor);

    #[doc = " Resumes the Cloud monitor."]
    #[doc = ""]
    #[doc = " @param monitor The monitor."]
    pub fn vnc_CloudAddressMonitor_resume(monitor: *mut vnc_CloudAddressMonitor);

    #[doc = " Sets whether or not the Cloud monitor pauses automatically when a connection"]
    #[doc = " is established.  Normally, a Cloud monitor does not need to run during a"]
    #[doc = " connection, so the default behaviour is to reduce bandwidth by pausing the"]
    #[doc = " monitor when a connection is established.  If @p pauseOnConnect is set to"]
    #[doc = " #vnc_false, the user must be careful to pause the monitor when possible,"]
    #[doc = " rather than continuously polling the network."]
    #[doc = ""]
    #[doc = " @param monitor The monitor."]
    #[doc = " @param pauseOnConnect Whether to pause when a new incoming connection is"]
    #[doc = "     established."]
    pub fn vnc_CloudAddressMonitor_setPauseOnConnect(
        monitor: *mut vnc_CloudAddressMonitor,
        pauseOnConnect: vnc_bool_t,
    );

    #[doc = " Specifies proxy server settings for Cloud connections; note these settings"]
    #[doc = " are adopted for all subsequent outgoing Cloud connections.  By default, the"]
    #[doc = " SDK employs the system configured proxy settings when making Cloud"]
    #[doc = " connections. You can specify a particular proxy server, or supply full user"]
    #[doc = " credentials. Note that any connection error arising from the proxy settings"]
    #[doc = " is reported when an outgoing connection is attempted; see"]
    #[doc = " @ref vnc_CloudConnector_connect."]
    #[doc = ""]
    #[doc = " @param systemProxy Set this to #vnc_true to employ the currently"]
    #[doc = "     configured system proxy settings. When set to #vnc_false, @p proxyUrl is"]
    #[doc = "     used to specify the proxy settings."]
    #[doc = " @param proxyUrl A string specifying a proxy server, plus user credentials"]
    #[doc = "     if required. The format of the string is"]
    #[doc = "     ``type://username:password@address::port``, where ``type`` is either"]
    #[doc = "     ``socks`` or ``http``, for example"]
    #[doc = "     ``socks://fred:X$frÂ£4Pw@mySocks5Proxy.here.com::8888``. Note that if"]
    #[doc = "     @p systemProxy is #vnc_false and @p proxyUrl is null or empty then this"]
    #[doc = "     is treated as a request to stop using a proxy server."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call"]
    #[doc = "     vnc_getLastError() to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     @p proxyUrl does not conform to the required format (see above)."]
    #[doc = ""]
    #[doc = " @since 1.4"]
    pub fn vnc_setCloudProxySettings(
        systemProxy: vnc_bool_t,
        proxyUrl: *const ::std::os::raw::c_char,
    ) -> vnc_status_t;
}

#[doc = " A peer is currently listening on the Cloud address."]
pub const vnc_CloudAddressMonitor_Availability_vnc_CloudAddressMonitor_Available:
    vnc_CloudAddressMonitor_Availability = 0;
#[doc = " No peer is currently listening on the Cloud address."]
pub const vnc_CloudAddressMonitor_Availability_vnc_CloudAddressMonitor_Unavailable:
    vnc_CloudAddressMonitor_Availability = 1;
#[doc = " The Cloud address monitor is waiting for the Cloud services to return the"]
#[doc = "  availability for the peer address, or an error occurred."]
pub const vnc_CloudAddressMonitor_Availability_vnc_CloudAddressMonitor_UnknownAvailability:
    vnc_CloudAddressMonitor_Availability = 2;
#[doc = " Enumeration of availabilities for a Cloud address."]
pub type vnc_CloudAddressMonitor_Availability = ::std::os::raw::c_uint;
#[doc = " Callback for a @ref vnc_CloudAddressMonitor."]
#[doc = ""]
#[doc = " @see vnc_CloudAddressMonitor_create()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_CloudAddressMonitor_Callback {
    #[doc = " Notification that the availability information for a Cloud address has"]
    #[doc = " changed.  This callback is required."]
    #[doc = ""]
    #[doc = " @param cloudAddress The address whose availability has changed."]
    #[doc = " @param availability The new value for the availability."]
    pub availabilityChanged: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            monitor: *mut vnc_CloudAddressMonitor,
            cloudAddress: *const ::std::os::raw::c_char,
            availability: vnc_CloudAddressMonitor_Availability,
        ),
    >,
    #[doc = " Notification that monitoring has been paused by an outgoing connection"]
    #[doc = " starting.  This callback is optional."]
    #[doc = ""]
    #[doc = " The monitor should not normally need to be restarted -- in particular, if"]
    #[doc = " availability information is not being displayed to the user the monitor"]
    #[doc = " should not be resumed."]
    pub monitorPaused: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            monitor: *mut vnc_CloudAddressMonitor,
        ),
    >,
}
#[test]
fn bindgen_test_layout_vnc_CloudAddressMonitor_Callback() {
    assert_eq!(
        ::std::mem::size_of::<vnc_CloudAddressMonitor_Callback>(),
        16usize,
        concat!("Size of: ", stringify!(vnc_CloudAddressMonitor_Callback))
    );
    assert_eq!(
        ::std::mem::align_of::<vnc_CloudAddressMonitor_Callback>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(vnc_CloudAddressMonitor_Callback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_CloudAddressMonitor_Callback>())).availabilityChanged
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_CloudAddressMonitor_Callback),
            "::",
            stringify!(availabilityChanged)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_CloudAddressMonitor_Callback>())).monitorPaused as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_CloudAddressMonitor_Callback),
            "::",
            stringify!(monitorPaused)
        )
    );
}
