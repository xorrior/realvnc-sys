/* automatically generated by rust-bindgen 0.59.2 */

pub const vnc_true: u32 = 1;
pub const vnc_false: u32 = 0;
pub const vnc_success: u32 = 1;
pub const vnc_failure: u32 = 0;
#[doc = " @name Common primitive types */"]
pub type vnc_int8_t = ::std::os::raw::c_schar;
pub type vnc_int16_t = ::std::os::raw::c_short;
pub type vnc_int32_t = ::std::os::raw::c_int;
pub type vnc_int64_t = ::std::os::raw::c_longlong;
pub type vnc_uint8_t = ::std::os::raw::c_uchar;
pub type vnc_uint16_t = ::std::os::raw::c_ushort;
pub type vnc_uint31_t = ::std::os::raw::c_uint;
pub type vnc_uint32_t = ::std::os::raw::c_uint;
pub type vnc_uint64_t = ::std::os::raw::c_ulonglong;
#[doc = " @name Boolean type"]
#[doc = " @details Note that #vnc_true and #vnc_false are guaranteed to be defined as"]
#[doc = " 1 and 0 respectively in all future versions of the SDK.  There is no need to"]
#[doc = " explicitly reference these constants, unless you prefer that coding style."]
pub type vnc_bool_t = ::std::os::raw::c_int;
#[doc = " @name Status type"]
#[doc = " @details Note that #vnc_success and #vnc_failure are guaranteed to be defined"]
#[doc = " as 1 and 0 respectively in all future versions of the SDK.  There is no need"]
#[doc = " to explicitly reference these constants, unless you prefer that coding style;"]
#[doc = " either of these is acceptable:"]
#[doc = ""]
#[doc = " @code"]
#[doc = " if (!vnc_Logger_createFileLogger(\"logfile.txt\"))"]
#[doc = "     handleError();"]
#[doc = " @endcode"]
#[doc = ""]
#[doc = " or:"]
#[doc = " @code"]
#[doc = " if (vnc_Logger_createFileLogger(\"logfile.txt\") != vnc_success)"]
#[doc = "     handleError();"]
#[doc = " @endcode"]
#[doc = ""]
pub type vnc_status_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Connection {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_ConnectionHandler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_AnnotationManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_MessagingManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DisplayManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DataBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Server {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Viewer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_PixelFormat {
    _unused: [u8; 0],
}
pub type vnc_assert_int8_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int16_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int32_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int64_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint8_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint16_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint31_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint32_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint64_t = [::std::os::raw::c_char; 1usize];
pub const vnc_DummyEnum_vnc_DummyEnum1: vnc_DummyEnum = 0;
pub const vnc_DummyEnum_vnc_DummyEnum2: vnc_DummyEnum = 1;
pub type vnc_DummyEnum = ::std::os::raw::c_uint;
pub type vnc_assert_DummyEnum = [::std::os::raw::c_char; 1usize];
pub type VncAssertionHandler =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;
#[doc = " Use the optimal capture method for the platform.  This is the default."]
pub const vnc_Server_CaptureMethod_vnc_Server_CaptureOptimal: vnc_Server_CaptureMethod = 0;
#[doc = " Use a fallback capture method under Windows and Linux.  This is likely to"]
#[doc = " be slower, but may solve rendering glitches with certain third-party"]
#[doc = " applications.  Not supported under Mac OS X."]
pub const vnc_Server_CaptureMethod_vnc_Server_CaptureFallback: vnc_Server_CaptureMethod = 1;
#[doc = " Enumeration of screen capture methods."]
#[doc = ""]
#[doc = " @see vnc_Server_setCaptureMethod()"]
pub type vnc_Server_CaptureMethod = ::std::os::raw::c_uint;
#[doc = " Grants a Viewer permission to see the screen.  Rarely omitted."]
pub const vnc_Server_Permissions_vnc_Server_PermView: vnc_Server_Permissions = 1;
#[doc = " Grants a Viewer permission to inject keyboard events."]
pub const vnc_Server_Permissions_vnc_Server_PermKeyboard: vnc_Server_Permissions = 2;
#[doc = " Grants a Viewer permission to inject mouse and touch events."]
pub const vnc_Server_Permissions_vnc_Server_PermPointer: vnc_Server_Permissions = 4;
#[doc = " Grants a Viewer permission to copy and paste text to and from the Server."]
pub const vnc_Server_Permissions_vnc_Server_PermClipboard: vnc_Server_Permissions = 8;
#[doc = " Grants a Viewer permission to draw on the Server screen."]
pub const vnc_Server_Permissions_vnc_Server_PermAnnotation: vnc_Server_Permissions = 16;
#[doc = " Grants a Viewer pemission to select the Server's display."]
pub const vnc_Server_Permissions_vnc_Server_PermSelectDisplay: vnc_Server_Permissions = 32;
#[doc = " Grants a Viewer pemission to listen to the Server."]
pub const vnc_Server_Permissions_vnc_Server_PermListen: vnc_Server_Permissions = 64;
#[doc = " Grants a Viewer a full set of permissions (that is, all of the above)."]
pub const vnc_Server_Permissions_vnc_Server_PermAll: vnc_Server_Permissions = 2147483647;
#[doc = " Enumeration of session permissions that can be granted to a connecting"]
#[doc = " Viewer.  (Flags can be combined into a mask.)"]
#[doc = ""]
#[doc = " @see vnc_Server_SecurityCallback::authenticateUser"]
pub type vnc_Server_Permissions = ::std::os::raw::c_uint;
#[doc = " Callback receiving connection-related notifications for a Server."]
#[doc = ""]
#[doc = " @see vnc_Server_setConnectionCallback()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Server_ConnectionCallback {
    #[doc = " Notification that a connection has successfully started."]
    #[doc = ""]
    #[doc = " This callback is notified when a Viewer has successfully authenticated and"]
    #[doc = " been granted a set of session permissions."]
    #[doc = ""]
    #[doc = " It is optional to define a callback function of this type.  Note that this"]
    #[doc = " callback is the only way to obtain a pointer to the @ref vnc_Connection"]
    #[doc = " object identifying this Viewer, required by some method calls."]
    #[doc = ""]
    #[doc = " This @ref vnc_Connection object is guaranteed to be valid until"]
    #[doc = " vnc_Server_ConnectionCallback::connectionEnded notifies you that it has"]
    #[doc = " been destroyed."]
    #[doc = ""]
    #[doc = " The connection count, as returned by vnc_Server_getConnectionCount(), is"]
    #[doc = " incremented @em before this callback is called."]
    #[doc = ""]
    #[doc = " @param connection The new connection."]
    pub connectionStarted: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            server: *mut vnc_Server,
            connection: *mut vnc_Connection,
        ),
    >,
    #[doc = " Notification that a connection has ended."]
    #[doc = ""]
    #[doc = " A callback of this type is made when a Viewer explicitly disconnects from"]
    #[doc = " the Server, or a VNC Cloud or other network error has occurred."]
    #[doc = ""]
    #[doc = " Note this callback function is called even if you call"]
    #[doc = " vnc_Server_disconnect() or vnc_Server_disconnectAll() to terminate"]
    #[doc = " connections yourself."]
    #[doc = ""]
    #[doc = " Only connections which have successfully authenticated and received a"]
    #[doc = " vnc_Server_ConnectionCallback::connectionStarted notification are notified"]
    #[doc = " throw this ended notification."]
    #[doc = ""]
    #[doc = " It is optional to define a callback function of this type, but note that"]
    #[doc = " memory corruption will occur if you call vnc_Server_disconnect() on a"]
    #[doc = " freed @ref vnc_Connection, so you must use this callback if you maintain a"]
    #[doc = " list of connected viewers."]
    #[doc = ""]
    #[doc = " The connection count, as returned by vnc_Server_getConnectionCount(), is"]
    #[doc = " decremented @em after this callback is called."]
    #[doc = ""]
    #[doc = " @param connection The viewer connection which has ended."]
    pub connectionEnded: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            server: *mut vnc_Server,
            connection: *mut vnc_Connection,
        ),
    >,
}
#[test]
fn bindgen_test_layout_vnc_Server_ConnectionCallback() {
    assert_eq!(
        ::std::mem::size_of::<vnc_Server_ConnectionCallback>(),
        16usize,
        concat!("Size of: ", stringify!(vnc_Server_ConnectionCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<vnc_Server_ConnectionCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(vnc_Server_ConnectionCallback))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Server_ConnectionCallback>())).connectionStarted as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Server_ConnectionCallback),
            "::",
            stringify!(connectionStarted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Server_ConnectionCallback>())).connectionEnded as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Server_ConnectionCallback),
            "::",
            stringify!(connectionEnded)
        )
    );
}
#[doc = " Callback receiving security-related notifications for a Server."]
#[doc = ""]
#[doc = " @see vnc_Server_setSecurityCallback()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Server_SecurityCallback {
    #[doc = " Verify a Viewer's cryptographic identity."]
    #[doc = ""]
    #[doc = " This callback is made when a Viewer makes a connection, but before"]
    #[doc = " authentication."]
    #[doc = ""]
    #[doc = " It is optional to define a callback function of this type.  Note that"]
    #[doc = " VNC Cloud mutually verifies peer identities for you, so this check"]
    #[doc = " is for peace-of-mind only (and only likely to be useful if you have"]
    #[doc = " out-of-band access to a list of all potential Viewer identities)."]
    #[doc = ""]
    #[doc = " @param connection The new connection.  Note that if the connection does not"]
    #[doc = "     subsequently authenticate itself, then the"]
    #[doc = "     vnc_Server_ConnectionCallback::connectionEnded notification will not be"]
    #[doc = "     called, therefore you should not cache or store the @ref vnc_Connection"]
    #[doc = "     pointer at this stage."]
    #[doc = " @param viewerHexFingerprint A human-readable hexadecimal representation"]
    #[doc = "     of a 2048-bit RSA public key hash."]
    #[doc = " @param viewerRsaPublic The Viewer's public key.  See"]
    #[doc = "     vnc_RsaKey_Callback::detailsReady for the format."]
    #[doc = ""]
    #[doc = " @return #vnc_true to continue the connection or #vnc_false to terminate it."]
    pub verifyPeer: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            server: *mut vnc_Server,
            connection: *mut vnc_Connection,
            viewerHexFingerprint: *const ::std::os::raw::c_char,
            viewerRsaPublic: *const vnc_DataBuffer,
        ) -> vnc_bool_t,
    >,
    #[doc = " Decide if a connecting Viewer is required to provide a user name."]
    #[doc = ""]
    #[doc = " This callback is made when a Viewer makes a connection, after peer identity"]
    #[doc = " verification has succeeded."]
    #[doc = ""]
    #[doc = " It is optional to define a callback function of this type, but note that"]
    #[doc = " if you do not, a connecting Viewer is required to provide a user name."]
    #[doc = ""]
    #[doc = " In your implementation, you should return #vnc_false if there is no need"]
    #[doc = " for a Viewer to provide a user name, and #vnc_true if there is."]
    #[doc = ""]
    #[doc = " @param connection The incoming connection.  Note that if the connection"]
    #[doc = "     does not subsequently authenticate itself, then the"]
    #[doc = "     vnc_Server_ConnectionCallback::connectionEnded notification will not be"]
    #[doc = "     called, therefore you should not cache or store the @ref vnc_Connection"]
    #[doc = "     pointer at this stage."]
    #[doc = ""]
    #[doc = " @return #vnc_false if a user name is not required, else #vnc_true."]
    pub isUserNameRequired: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            server: *mut vnc_Server,
            connection: *mut vnc_Connection,
        ) -> vnc_bool_t,
    >,
    #[doc = " Decide if a connecting Viewer is required to provide a password."]
    #[doc = ""]
    #[doc = " This callback is made when a Viewer makes a connection, after peer identity"]
    #[doc = " verification has succeeded."]
    #[doc = ""]
    #[doc = " It is optional to define a callback function of this type, but note that"]
    #[doc = " if you do not, a connecting Viewer is required to provide a password."]
    #[doc = ""]
    #[doc = " In your implementation, you should return #vnc_false if there is no need"]
    #[doc = " for a Viewer to provide a password, and #vnc_true if there is."]
    #[doc = ""]
    #[doc = " @param connection The incoming connection.  Note that if the connection"]
    #[doc = "     does not subsequently authenticate itself, then the"]
    #[doc = "     vnc_Server_ConnectionCallback::connectionEnded notification will not be"]
    #[doc = "     called, therefore you should not cache or store the @ref vnc_Connection"]
    #[doc = "     pointer at this stage."]
    #[doc = ""]
    #[doc = " @return #vnc_false if a password is not required, else #vnc_true."]
    pub isPasswordRequired: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            server: *mut vnc_Server,
            connection: *mut vnc_Connection,
        ) -> vnc_bool_t,
    >,
    #[doc = " Authenticate credentials presented by a Viewer."]
    #[doc = ""]
    #[doc = " This callback is made when a Viewer has sent credentials to be"]
    #[doc = " authenticated, after the Server has requested the details returned by the"]
    #[doc = " vnc_Server_SecurityCallback::isUserNameRequired and"]
    #[doc = " vnc_Server_SecurityCallback::isPasswordRequired callbacks."]
    #[doc = ""]
    #[doc = " It is mandatory to define this callback function."]
    #[doc = ""]
    #[doc = " In your implementation, you should authenticate @p username and"]
    #[doc = " @p password, and either return 0 to terminate the"]
    #[doc = " connection, or any combination of the @ref vnc_Server_Permissions flags to"]
    #[doc = " simultaneously approve the connection and grant a set of session"]
    #[doc = " permissions."]
    #[doc = ""]
    #[doc = " Please see the <a href=\"http://www.securecoding.cert.org\">CERT Coding"]
    #[doc = " Standards</a> for guidelines on handling passwords in reusable memory, in"]
    #[doc = " particular sections MSC18-C and MEM03-C."]
    #[doc = ""]
    #[doc = " @param connection The incoming connection."]
    #[doc = " @param username The user name provided by the Viewer.  This is provided"]
    #[doc = "     according to whether vnc_Server_SecurityCallback::isUserNameRequired"]
    #[doc = "     requested it (provided by default)."]
    #[doc = " @param password The password provided by the Viewer.  This is provided"]
    #[doc = "     according to whether vnc_Server_SecurityCallback::isPasswordRequired"]
    #[doc = "     requested it (provided by default)."]
    #[doc = ""]
    #[doc = " @return Any combination of the @ref vnc_Server_Permissions flags, or 0"]
    #[doc = "     (no permissions) to reject the connection."]
    pub authenticateUser: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            server: *mut vnc_Server,
            connection: *mut vnc_Connection,
            username: *const ::std::os::raw::c_char,
            password: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_vnc_Server_SecurityCallback() {
    assert_eq!(
        ::std::mem::size_of::<vnc_Server_SecurityCallback>(),
        32usize,
        concat!("Size of: ", stringify!(vnc_Server_SecurityCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<vnc_Server_SecurityCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(vnc_Server_SecurityCallback))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Server_SecurityCallback>())).verifyPeer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Server_SecurityCallback),
            "::",
            stringify!(verifyPeer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Server_SecurityCallback>())).isUserNameRequired as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Server_SecurityCallback),
            "::",
            stringify!(isUserNameRequired)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Server_SecurityCallback>())).isPasswordRequired as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Server_SecurityCallback),
            "::",
            stringify!(isPasswordRequired)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Server_SecurityCallback>())).authenticateUser as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Server_SecurityCallback),
            "::",
            stringify!(authenticateUser)
        )
    );
}
#[doc = " Callback for handling input events."]
#[doc = ""]
#[doc = " @see vnc_Server_setInputEventsCallback()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Server_InputEventsCallback {
    #[doc = " Handle pointer events manually."]
    #[doc = ""]
    #[doc = " This callback is made when a Viewer has sent pointer events"]
    #[doc = " to the server. Return false to have the Server handle the pointer"]
    #[doc = " event as normal, or true to indicate it has been handled and"]
    #[doc = " should therefore cancel the default handling."]
    #[doc = ""]
    #[doc = " @param x The X position of the pointer event."]
    #[doc = " @param y The Y position of the pointer event."]
    #[doc = " @param buttonMask Bitmask of which buttons are down on the pointing device."]
    #[doc = "                   The first bit is the main button, the second bit is the secondary button, etc ..."]
    #[doc = " @param isRelative #vnc_true if the (x,y) position is relative to the last pointer position"]
    #[doc = "                   #vnc_false if the position is absolute."]
    #[doc = ""]
    #[doc = " @return #vnc_true if the pointer-event is to be handled by the SDK caller (i.e. override the behaviour),"]
    #[doc = "         #vnc_false if the pointer-event is to be handled by the Server as normal (default behaviour)."]
    pub pointerEventCallback: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            server: *mut vnc_Server,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            buttonMask: ::std::os::raw::c_int,
            isRelative: vnc_bool_t,
        ) -> vnc_bool_t,
    >,
    #[doc = " Handle keypress events manually."]
    #[doc = ""]
    #[doc = " This callback is made when a Viewer has sent keypress events"]
    #[doc = " to the server. Return false to have the Server handle the keypress"]
    #[doc = " event as normal, or true to indicate it has been handled and"]
    #[doc = " should cancel the default handling."]
    #[doc = ""]
    #[doc = " @param key Key pressed from the Viewer. Expressed as an X11 keysym code. See keyboard.h."]
    #[doc = " @param down True if this is the \"down\" event, false if this is the \"up\" event."]
    #[doc = ""]
    #[doc = " @return #vnc_true if the keypress event is to be handled by the SDK caller (i.e. override the behaviour),"]
    #[doc = "         #vnc_false if the keypress event is to be handled by the Server as normal (default behaviour)."]
    pub keyEventCallback: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            server: *mut vnc_Server,
            key: ::std::os::raw::c_int,
            down: vnc_bool_t,
        ) -> vnc_bool_t,
    >,
}
#[test]
fn bindgen_test_layout_vnc_Server_InputEventsCallback() {
    assert_eq!(
        ::std::mem::size_of::<vnc_Server_InputEventsCallback>(),
        16usize,
        concat!("Size of: ", stringify!(vnc_Server_InputEventsCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<vnc_Server_InputEventsCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(vnc_Server_InputEventsCallback))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Server_InputEventsCallback>())).pointerEventCallback
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Server_InputEventsCallback),
            "::",
            stringify!(pointerEventCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Server_InputEventsCallback>())).keyEventCallback as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Server_InputEventsCallback),
            "::",
            stringify!(keyEventCallback)
        )
    );
}
#[doc = " Callback receiving agent-related notifications for a Server."]
#[doc = ""]
#[doc = " @see vnc_Server_setAgentCallback()."]
#[doc = ""]
#[doc = " @since 1.1"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Server_AgentCallback {
    #[doc = " Notification that the agent has started."]
    #[doc = ""]
    #[doc = " Note that the agent is normally started automatically as soon as the server"]
    #[doc = " is created via vnc_Server_create() or vnc_Server_createService()."]
    #[doc = ""]
    #[doc = " This callback is optional."]
    pub agentStarted: ::std::option::Option<
        unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void, server: *mut vnc_Server),
    >,
    #[doc = " Notification that the agent has stopped."]
    #[doc = ""]
    #[doc = " This may indicate that the user has logged out or (on Linux) the X server"]
    #[doc = " has stopped."]
    #[doc = ""]
    #[doc = " This callback is optional."]
    pub agentStopped: ::std::option::Option<
        unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void, server: *mut vnc_Server),
    >,
}
#[test]
fn bindgen_test_layout_vnc_Server_AgentCallback() {
    assert_eq!(
        ::std::mem::size_of::<vnc_Server_AgentCallback>(),
        16usize,
        concat!("Size of: ", stringify!(vnc_Server_AgentCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<vnc_Server_AgentCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(vnc_Server_AgentCallback))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Server_AgentCallback>())).agentStarted as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Server_AgentCallback),
            "::",
            stringify!(agentStarted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Server_AgentCallback>())).agentStopped as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Server_AgentCallback),
            "::",
            stringify!(agentStopped)
        )
    );
}
extern "C" {
    #[doc = " Creates a Server.  Note only one @ref vnc_Server should exist in your"]
    #[doc = " application at a time."]
    #[doc = ""]
    #[doc = " The Server captures the current session, which may be switched-out or"]
    #[doc = " otherwise not visible on the console."]
    #[doc = ""]
    #[doc = " @param agentPath The full path to the @c vncagent executable, or NULL to"]
    #[doc = "     specify that @c vncagent is in the same directory as the app"]
    #[doc = "     binary at run-time.  If you provide a directory, the executable must be"]
    #[doc = "     called @c vncagent (@c vncagent.exe on Windows); if you have renamed"]
    #[doc = "     @c vncagent then the filename must be provided."]
    #[doc = ""]
    #[doc = " @return A new @ref vnc_Server or NULL on error, in which case call"]
    #[doc = "     vnc_getLastError() to get the error code."]
    #[doc = ""]
    #[doc = " @retval FileError"]
    #[doc = "     @c vncagent could not be found, or the file specified does not exist"]
    #[doc = " @retval AgentError"]
    #[doc = "     @c vncagent cannot be executed or its version number does not match that"]
    #[doc = "     of the SDK"]
    #[doc = " @retval UnexpectedCall"]
    #[doc = "     A @ref vnc_Server already exists in your application"]
    #[doc = ""]
    #[doc = " @see Use vnc_Server_createService() to create a Server which captures the"]
    #[doc = "     console."]
    pub fn vnc_Server_create(agentPath: *const ::std::os::raw::c_char) -> *mut vnc_Server;
}
extern "C" {
    #[doc = " Creates a Server running as a service.  Note only one @ref vnc_Server should"]
    #[doc = " exist in your application at a time."]
    #[doc = ""]
    #[doc = " The Server captures the machine's console, which may be a logged-in user"]
    #[doc = " session or a login prompt.  Running as a service requires elevated"]
    #[doc = " privileges, and must be done from a Windows Service (Windows), a launch"]
    #[doc = " daemon (Mac), or a root process (Linux)."]
    #[doc = ""]
    #[doc = " On Windows, the @c vncagent executable must be located within either the"]
    #[doc = " <tt>\\%ProgramFiles\\%</tt> or <tt>\\%ProgramFiles(x86)\\%</tt> directories"]
    #[doc = " in order to allow the injection of secure key sequences (e.g. Ctrl-Alt-Del)."]
    #[doc = ""]
    #[doc = " On Mac OS X, an instance of @c vncagent must separately be run in each"]
    #[doc = " graphical session as a launch agent.  The @p agentPath provided here must"]
    #[doc = " match the path of these launch agents in order that the SDK can communicate"]
    #[doc = " with them."]
    #[doc = ""]
    #[doc = " @param agentPath The path to the @c vncagent executable (see"]
    #[doc = "     vnc_Server_create() for details)."]
    #[doc = ""]
    #[doc = " @return A new @ref vnc_Server or NULL on error, in which case call"]
    #[doc = "     vnc_getLastError() to get the error code."]
    #[doc = ""]
    #[doc = " @retval AgentError"]
    #[doc = "     @c vncagent cannot be found or its version number does not match that"]
    #[doc = "     of the SDK"]
    #[doc = " @retval UnexpectedCall"]
    #[doc = "     A @ref vnc_Server already exists in your application"]
    #[doc = ""]
    #[doc = " @see Use vnc_Server_create() to create a Server which captures the"]
    #[doc = "     current session."]
    #[doc = ""]
    #[doc = " @since 1.1"]
    pub fn vnc_Server_createService(agentPath: *const ::std::os::raw::c_char) -> *mut vnc_Server;
}
extern "C" {
    #[doc = " Destroys the Server."]
    #[doc = ""]
    #[doc = " Any Viewers still connected will be disconnected, and the peer's"]
    #[doc = " @ref vnc_Viewer_CanReconnect flag will be set, indicating that server may"]
    #[doc = " start again soon.  If this is not desired, call vnc_Server_disconnectAll()"]
    #[doc = " without the @ref vnc_Server_DisconnectReconnect flag before destroying"]
    #[doc = " the Server."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    pub fn vnc_Server_destroy(server: *mut vnc_Server);
}
extern "C" {
    #[doc = " Sets connection-related callbacks for the Server."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = " @param callback The new connection event callback."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call"]
    #[doc = " vnc_getLastError() to get the error code."]
    pub fn vnc_Server_setConnectionCallback(
        server: *mut vnc_Server,
        callback: *const vnc_Server_ConnectionCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Returns the total number of Viewers currently connected to the Server."]
    #[doc = ""]
    #[doc = " @since 1.1"]
    pub fn vnc_Server_getConnectionCount(server: *mut vnc_Server) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets security-related callbacks for the Server."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = " @param callback The new security event callback."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call"]
    #[doc = " vnc_getLastError() to get the error code."]
    pub fn vnc_Server_setSecurityCallback(
        server: *mut vnc_Server,
        callback: *const vnc_Server_SecurityCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Changes permissions for a Viewer mid-session."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = " @param connection The Viewer whose permissions to change."]
    #[doc = " @param perms Any combination of the @ref vnc_Server_Permissions flags, or"]
    #[doc = "     0 (no permissions) to render the session ineffective."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call"]
    #[doc = " vnc_getLastError() to get the error code."]
    pub fn vnc_Server_setPermissions(
        server: *mut vnc_Server,
        connection: *mut vnc_Connection,
        perms: ::std::os::raw::c_int,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Gets the set of current permissions for a Viewer."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = " @param connection The Viewer whose permissions to get."]
    #[doc = ""]
    #[doc = " @return Zero or more of the @ref vnc_Server_Permissions flags."]
    pub fn vnc_Server_getPermissions(
        server: *mut vnc_Server,
        connection: *mut vnc_Connection,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets agent-related callbacks for the Server."]
    #[doc = ""]
    #[doc = " These are not used on Android."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = " @param callback The new agent event callback."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call"]
    #[doc = "     vnc_getLastError() to get the error code."]
    #[doc = ""]
    #[doc = " @since 1.1"]
    pub fn vnc_Server_setAgentCallback(
        server: *mut vnc_Server,
        callback: *const vnc_Server_AgentCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Determines if the @c vncagent process is ready and available to capture the"]
    #[doc = " display and inject input events."]
    #[doc = ""]
    #[doc = " If the @c vncagent is not ready, then the display cannot be captured at present."]
    #[doc = " This could be because it is starting up or being restarted due to a user"]
    #[doc = " logout, or an error. On Linux, this can also indicate that the X server is"]
    #[doc = " not running. On Android, @c vncagent is not used and this function will always"]
    #[doc = " return #vnc_true."]
    #[doc = ""]
    #[doc = " See vnc_Server_setAgentCallback() for receiving callbacks when the agent"]
    #[doc = " process starts and stops."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = ""]
    #[doc = " @retval #vnc_true"]
    #[doc = "     The @c vncagent process is ready"]
    #[doc = ""]
    #[doc = " @retval #vnc_false"]
    #[doc = "     The @c vncagent process is not ready or not running."]
    #[doc = ""]
    #[doc = " @since 1.1"]
    pub fn vnc_Server_isAgentReady(server: *mut vnc_Server) -> vnc_bool_t;
}
extern "C" {
    #[doc = " Specifies a friendly name for the Server, to send to connected Viewers."]
    #[doc = " By default, this is the device's hostname, plus the display number"]
    #[doc = " where appropriate."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = " @param name The UTF-8-encoded friendly name."]
    pub fn vnc_Server_setFriendlyName(server: *mut vnc_Server, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Obtains the Server's @ref vnc_ConnectionHandler for performing connection"]
    #[doc = " operations."]
    #[doc = ""]
    #[doc = " Typically, a @ref vnc_ConnectionHandler is passed to"]
    #[doc = " vnc_CloudListener_create() to start the Server listening for connections."]
    #[doc = " However, you can reverse this methodology and pass it to"]
    #[doc = " vnc_CloudConnector_create() instead in order to connect to listening Viewers"]
    #[doc = " if you want (see Viewer.h for more information)."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = ""]
    #[doc = " @return A @ref vnc_ConnectionHandler, valid for the lifetime of the Server."]
    pub fn vnc_Server_getConnectionHandler(server: *mut vnc_Server) -> *mut vnc_ConnectionHandler;
}
extern "C" {
    #[doc = " Returns the address of a particular connected Viewer."]
    #[doc = ""]
    #[doc = " The format of the null-terminated string is"]
    #[doc = " <tt>[vnccloud:\\<cloud-address\\>]:\\<id\\></tt>"]
    #[doc = " Note the string is only guaranteed to be valid until the next method call."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = " @param connection The connection whose Cloud address you want.  You can"]
    #[doc = "     obtain a @ref vnc_Connection from your callback function"]
    #[doc = "     vnc_Server_ConnectionCallback::connectionStarted."]
    #[doc = ""]
    #[doc = " @return A NULL-terminated string in the format"]
    #[doc = "     <tt>[vnccloud:\\<cloud-address\\>]:\\<id\\></tt>."]
    pub fn vnc_Server_getPeerAddress(
        server: *mut vnc_Server,
        connection: *mut vnc_Connection,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " The disconnection message is deemed to be sufficiently important that the"]
#[doc = " Viewer should alert the Viewer user."]
pub const vnc_Server_DisconnectFlags_vnc_Server_DisconnectAlert: vnc_Server_DisconnectFlags = 1;
#[doc = " Set the peer's @ref vnc_Viewer_CanReconnect flag, that is, the Server"]
#[doc = " informs the Viewer that the server may start again soon."]
pub const vnc_Server_DisconnectFlags_vnc_Server_DisconnectReconnect: vnc_Server_DisconnectFlags = 2;
#[doc = " Enumeration of disconnection flags."]
#[doc = ""]
#[doc = " @see vnc_Server_disconnect(), vnc_Server_disconnectAll()"]
#[doc = ""]
#[doc = " @since 1.1"]
pub type vnc_Server_DisconnectFlags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Disconnects a particular Viewer, optionally specifying a message."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = " @param connection The connection to terminate.  You can obtain a"]
    #[doc = "     @ref vnc_Connection from your callback function"]
    #[doc = "     vnc_Server_ConnectionCallback::connectionStarted."]
    #[doc = " @param message The message to send to the Viewer."]
    #[doc = " @param flags Zero or more of the @ref vnc_Server_DisconnectFlags flags."]
    #[doc = ""]
    #[doc = " @see vnc_Viewer_getDisconnectMessage()"]
    pub fn vnc_Server_disconnect(
        server: *mut vnc_Server,
        connection: *mut vnc_Connection,
        message: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Disconnects all Viewers, optionally specifying a message."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = " @param message The message to send to all Viewers."]
    #[doc = " @param flags Zero or more of the @ref vnc_Server_DisconnectFlags flags."]
    #[doc = ""]
    #[doc = " @see vnc_Viewer_getDisconnectMessage()"]
    pub fn vnc_Server_disconnectAll(
        server: *mut vnc_Server,
        message: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Specifies a blacklist threshold and timeout for the Server.  By default,"]
    #[doc = " the threshold is 5, which means that a Viewer failing to authenticate five"]
    #[doc = " times in a row is blacklisted for the default timeout of 10 seconds.  This"]
    #[doc = " guards against brute-force and dictionary attacks."]
    #[doc = ""]
    #[doc = " To completely disable blacklisting, set @p threshold and @p timeout to 0."]
    #[doc = " For security reasons this is not recommended."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = " @param threshold A number of unsuccessful authentication attempts before"]
    #[doc = "     blacklisting."]
    #[doc = " @param timeout A number of seconds before a blacklisted Viewer can attempt"]
    #[doc = "     to authenticate again."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     @p timeout is zero or negative"]
    pub fn vnc_Server_setBlacklist(
        server: *mut vnc_Server,
        threshold: ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Handles a Windows Service control event.  When Server has been created via"]
    #[doc = " vnc_Server_createService(), then Windows Service control events must be"]
    #[doc = " forwarded to the Server so that active session can be determined. See the"]
    #[doc = " Win32 function"]
    #[doc = " <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms685058(v=vs.85).aspx\">RegisterServiceCtrlHandlerEx</a>"]
    #[doc = " and the <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms683241(v=vs.85).aspx\">HandlerEx</a>"]
    #[doc = " callback for more information."]
    #[doc = ""]
    #[doc = " This function can be called for all notifications received via your @c HandlerEx"]
    #[doc = " callback, but in particular it must be called for notifications where the"]
    #[doc = " control code (@p dwControl) is @c SERVICE_CONTROL_SESSIONCHANGE."]
    #[doc = ""]
    #[doc = " This method is designed to be called from the Service Control Dispatcher"]
    #[doc = " thread, rather than the thread which called vnc_init()."]
    #[doc = ""]
    #[doc = " @param dwControl The control code passed to @c HandlerEx"]
    #[doc = " @param dwEventType The type of event passed to @c HandlerEx"]
    #[doc = " @param lpEventData The event data passed to @c HandlerEx"]
    #[doc = ""]
    #[doc = " @since 1.1"]
    pub fn vnc_Server_serviceControlHandlerEx(
        server: *mut vnc_Server,
        dwControl: ::std::os::raw::c_int,
        dwEventType: ::std::os::raw::c_int,
        lpEventData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Enables transmission of audio from the Server to the Viewer. The audio"]
    #[doc = " stream will be automatically negotiated with the peer endpoint, if"]
    #[doc = " possible, and any audio data will be captured from the device's default"]
    #[doc = " audio mixer."]
    #[doc = " By default, this is enabled and the Server will attempt to negotiate an"]
    #[doc = " audio channel with any connecting viewers."]
    #[doc = ""]
    #[doc = " @param server The Server."]
    #[doc = " @param enable #vnc_true to enable audio playback, #vnc_false to disable."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval PeerNotSupported"]
    #[doc = "     The peer endpoint does not support audio"]
    #[doc = ""]
    #[doc = " @retval NotSupported"]
    #[doc = "     This platform does not support audio"]
    #[doc = ""]
    #[doc = " @since 1.9"]
    pub fn vnc_Server_enableAudio(server: *mut vnc_Server, enable: vnc_bool_t) -> vnc_status_t;
}
extern "C" {
    #[doc = " Obtains the Server's @ref vnc_AnnotationManager for handling annotation"]
    #[doc = " operations."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = ""]
    #[doc = " @return A @ref vnc_AnnotationManager, valid for the lifetime of the Server."]
    #[doc = ""]
    #[doc = " @since 1.4"]
    pub fn vnc_Server_getAnnotationManager(server: *mut vnc_Server) -> *mut vnc_AnnotationManager;
}
extern "C" {
    #[doc = " Obtains the Server's @ref vnc_MessagingManager for handling messaging."]
    #[doc = ""]
    #[doc = " @return A @ref vnc_MessagingManager or NULL on error, in which case"]
    #[doc = "     call vnc_getLastError() to get the error code."]
    #[doc = ""]
    #[doc = " @retval NotEnabled"]
    #[doc = "     The Messaging feature is not enabled for this Server."]
    #[doc = ""]
    #[doc = " @since 1.5"]
    pub fn vnc_Server_getMessagingManager(server: *mut vnc_Server) -> *mut vnc_MessagingManager;
}
extern "C" {
    #[doc = " Obtains the Server's @ref vnc_DisplayManager, for managing the list of"]
    #[doc = " displays made available by the Server and for setting the Server's"]
    #[doc = " capture method."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = " @return A @ref vnc_DisplayManager or NULL on error, in which case"]
    #[doc = "     call vnc_getLastError() to get the error code."]
    #[doc = ""]
    #[doc = " @since 1.5"]
    pub fn vnc_Server_getDisplayManager(server: *mut vnc_Server) -> *mut vnc_DisplayManager;
}
#[doc = " Use strong encryption.  This is the default."]
pub const vnc_Server_EncryptionLevel_vnc_Server_EncryptionLevel_Default:
    vnc_Server_EncryptionLevel = 0;
#[doc = " Use the strongest available encryption, possibly at the cost of speed."]
pub const vnc_Server_EncryptionLevel_vnc_Server_EncryptionLevel_Maximum:
    vnc_Server_EncryptionLevel = 1;
#[doc = " Allow the negotation of encryption levels, including no encryption."]
#[doc = " Use with caution."]
#[doc = " Requires a Third-Party Connectivity Add-on."]
pub const vnc_Server_EncryptionLevel_vnc_Server_EncryptionLevel_AllowUnencrypted:
    vnc_Server_EncryptionLevel = 2;
#[doc = " Enumeration of encryption levels."]
#[doc = ""]
#[doc = " @see vnc_Server_setEncryptionLevel()"]
pub type vnc_Server_EncryptionLevel = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Sets the desired encryption level of the session from the range of options"]
    #[doc = " enumerated by @ref vnc_Server_EncryptionLevel."]
    #[doc = ""]
    #[doc = " This will not affect the encryption level of established connections."]
    #[doc = ""]
    #[doc = " If a Viewer and Server select different encryption levels, connections"]
    #[doc = " between them take place at the higher of their selected levels."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = " @param level The new encryption level."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     The encryption level is invalid"]
    pub fn vnc_Server_setEncryptionLevel(
        server: *mut vnc_Server,
        level: vnc_Server_EncryptionLevel,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Returns the encryption level being used with an incoming connection,"]
    #[doc = " or the Server's current encryption level if the connection is NULL."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = " @param connection The incoming connection or NULL."]
    pub fn vnc_Server_getEncryptionLevel(
        server: *mut vnc_Server,
        connection: *mut vnc_Connection,
    ) -> vnc_Server_EncryptionLevel;
}
extern "C" {
    #[doc = " Set a password for use with third-party VNC Viewers, using VncAuth"]
    #[doc = " authentication."]
    #[doc = " Use in conjunction with vnc_Server_setEncryptionLevel(), setting the level"]
    #[doc = " to vnc_Server_EncryptionLevel_AllowUnencrypted, enabled by the Third-Party"]
    #[doc = " Connectivity add-on."]
    #[doc = " If all requirements above are met, this password will be used instead of"]
    #[doc = " the @ref vnc_Server_SecurityCallback callbacks."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = " @param password The VncAuth password."]
    #[doc = ""]
    #[doc = " @retval UnexpectedCall"]
    #[doc = "        The Third-Party Connectivity Add-on is not available"]
    #[doc = ""]
    pub fn vnc_Server_setVncAuthPassword(
        server: *mut vnc_Server,
        password: *const ::std::os::raw::c_char,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Sets the number of seconds to wait before disconnecting idle Viewers."]
    #[doc = " To turn off the idle timeout, use a value of 0."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = " @param idleTimeout The idle timeout in seconds."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     The idle timeout is invalid"]
    pub fn vnc_Server_setIdleTimeout(
        server: *mut vnc_Server,
        idleTimeout: ::std::os::raw::c_int,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Gets the current number of seconds to wait before disconnecting idle"]
    #[doc = " Viewers. A value of 0 indicates no timeout is set."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    pub fn vnc_Server_getIdleTimeout(server: *mut vnc_Server) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets input control related callbacks for the Server."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = " @param callback The new input event callbacks."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call"]
    #[doc = " vnc_getLastError() to get the error code."]
    pub fn vnc_Server_setInputEventsCallback(
        server: *mut vnc_Server,
        callback: *const vnc_Server_InputEventsCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Specifies the screen capture method used by the Server.  By default, an"]
    #[doc = " optimal method is chosen for each platform.  In the unlikely event you"]
    #[doc = " experience screen capture issues under Windows or Linux, try the fallback"]
    #[doc = " method (this is not supported under Mac OS X)."]
    #[doc = ""]
    #[doc = " @param server The current Server."]
    #[doc = " @param captureMethod One of the @ref vnc_Server_CaptureMethod flags."]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call"]
    #[doc = "     vnc_getLastError() to get the error code."]
    #[doc = ""]
    #[doc = " @retval NotSupported"]
    #[doc = "     @p captureMethod is not supported on this platform."]
    pub fn vnc_Server_setCaptureMethod(
        server: *mut vnc_Server,
        captureMethod: vnc_Server_CaptureMethod,
    ) -> vnc_status_t;
}
