/* automatically generated by rust-bindgen 0.59.2 */

pub const vnc_true: u32 = 1;
pub const vnc_false: u32 = 0;
pub const vnc_success: u32 = 1;
pub const vnc_failure: u32 = 0;
#[doc = " @name Common primitive types */"]
pub type vnc_int8_t = ::std::os::raw::c_schar;
pub type vnc_int16_t = ::std::os::raw::c_short;
pub type vnc_int32_t = ::std::os::raw::c_int;
pub type vnc_int64_t = ::std::os::raw::c_longlong;
pub type vnc_uint8_t = ::std::os::raw::c_uchar;
pub type vnc_uint16_t = ::std::os::raw::c_ushort;
pub type vnc_uint31_t = ::std::os::raw::c_uint;
pub type vnc_uint32_t = ::std::os::raw::c_uint;
pub type vnc_uint64_t = ::std::os::raw::c_ulonglong;
#[doc = " @name Boolean type"]
#[doc = " @details Note that #vnc_true and #vnc_false are guaranteed to be defined as"]
#[doc = " 1 and 0 respectively in all future versions of the SDK.  There is no need to"]
#[doc = " explicitly reference these constants, unless you prefer that coding style."]
pub type vnc_bool_t = ::std::os::raw::c_int;
#[doc = " @name Status type"]
#[doc = " @details Note that #vnc_success and #vnc_failure are guaranteed to be defined"]
#[doc = " as 1 and 0 respectively in all future versions of the SDK.  There is no need"]
#[doc = " to explicitly reference these constants, unless you prefer that coding style;"]
#[doc = " either of these is acceptable:"]
#[doc = ""]
#[doc = " @code"]
#[doc = " if (!vnc_Logger_createFileLogger(\"logfile.txt\"))"]
#[doc = "     handleError();"]
#[doc = " @endcode"]
#[doc = ""]
#[doc = " or:"]
#[doc = " @code"]
#[doc = " if (vnc_Logger_createFileLogger(\"logfile.txt\") != vnc_success)"]
#[doc = "     handleError();"]
#[doc = " @endcode"]
#[doc = ""]
pub type vnc_status_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Connection {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_ConnectionHandler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_AnnotationManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_MessagingManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DisplayManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DataBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Server {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Viewer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_PixelFormat {
    _unused: [u8; 0],
}
pub type vnc_assert_int8_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int16_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int32_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int64_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint8_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint16_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint31_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint32_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint64_t = [::std::os::raw::c_char; 1usize];
pub const vnc_DummyEnum_vnc_DummyEnum1: vnc_DummyEnum = 0;
pub const vnc_DummyEnum_vnc_DummyEnum2: vnc_DummyEnum = 1;
pub type vnc_DummyEnum = ::std::os::raw::c_uint;
pub type vnc_assert_DummyEnum = [::std::os::raw::c_char; 1usize];
pub type VncAssertionHandler =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;
#[doc = " Information that the program is likely to stop functioning correctly."]
pub const vnc_Logger_Level_vnc_Logger_Error: vnc_Logger_Level = 0;
#[doc = " Useful information on the functioning of the system.  This is the"]
#[doc = " default log level."]
pub const vnc_Logger_Level_vnc_Logger_Basic: vnc_Logger_Level = 1;
#[doc = " Comprehensive logging of all SDK operations (may degrade performance,"]
#[doc = " and the log file will also contain secure information such as keystrokes)"]
pub const vnc_Logger_Level_vnc_Logger_Full: vnc_Logger_Level = 2;
#[doc = " Logging of SDK operations, and for debug purposes, logging of internal"]
#[doc = " information specific to RealVNC's implementation."]
pub const vnc_Logger_Level_vnc_Logger_Debug: vnc_Logger_Level = 3;
#[doc = " Enumeration of log levels.  These can be used to filter out log messages"]
#[doc = " that are not needed.  Each level includes lower levels as well."]
pub type vnc_Logger_Level = ::std::os::raw::c_uint;
#[doc = " Callback which handles log messages."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Logger_Callback {
    #[doc = " Notification of log messages generated by the SDK.  This callback is"]
    #[doc = " required for a custom logger.  The callback is only notified for messages"]
    #[doc = " with level less than or equal to the current log level."]
    #[doc = ""]
    #[doc = " @param level The lowest level at which the message would be generated."]
    #[doc = " @param message A human-readable description of an event, encoded as UTF-8"]
    #[doc = "     and containing no ASCII control characters or newlines."]
    pub logMessage: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            level: vnc_Logger_Level,
            message: *const ::std::os::raw::c_char,
        ),
    >,
}
#[test]
fn bindgen_test_layout_vnc_Logger_Callback() {
    assert_eq!(
        ::std::mem::size_of::<vnc_Logger_Callback>(),
        8usize,
        concat!("Size of: ", stringify!(vnc_Logger_Callback))
    );
    assert_eq!(
        ::std::mem::align_of::<vnc_Logger_Callback>(),
        8usize,
        concat!("Alignment of ", stringify!(vnc_Logger_Callback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vnc_Logger_Callback>())).logMessage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Logger_Callback),
            "::",
            stringify!(logMessage)
        )
    );
}
extern "C" {
    #[doc = " Sets the current log level.  Messages will only be logged whose level is less"]
    #[doc = " than or equal to this.  See the @ref vnc_Logger_Level enumeration for"]
    #[doc = " possible log levels."]
    #[doc = ""]
    #[doc = " @param level The new level."]
    pub fn vnc_Logger_setLevel(level: vnc_Logger_Level);
}
extern "C" {
    #[doc = " Creates a logger implementation that calls the given callback whenever a log"]
    #[doc = " message is written.  This destroys any previously-created logger."]
    #[doc = ""]
    #[doc = " @param callback The new callback."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     The vnc_Logger_Callback::logMessage callback is NULL"]
    pub fn vnc_Logger_createCustomLogger(
        callback: *const vnc_Logger_Callback,
        userData: *mut ::std::os::raw::c_void,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Creates a logger that writes data to the specified log file.  This function"]
    #[doc = " is not available on the HTML5 platform.  This destroys any previously-created"]
    #[doc = " logger."]
    #[doc = ""]
    #[doc = " @param path A full path to and name for the log file."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     @p path is invalid"]
    #[doc = " @retval FileError"]
    #[doc = "     The log file could not be opened or created"]
    pub fn vnc_Logger_createFileLogger(path: *const ::std::os::raw::c_char) -> vnc_status_t;
}
extern "C" {
    #[doc = " Creates a logger implementation that writes data to the Android log.  This"]
    #[doc = " function is only available on Android.  This destroys any previously-created"]
    #[doc = " logger."]
    pub fn vnc_Logger_createAndroidLogger();
}
extern "C" {
    #[doc = " Creates a logger implementation that writes data to stderr.  This function is"]
    #[doc = " not available on the HTML5 platform.  This destroys any previously-created"]
    #[doc = " logger."]
    pub fn vnc_Logger_createStderrLogger();
}
extern "C" {
    #[doc = " Creates a logger implementation that writes data to the web browser's"]
    #[doc = " debugging console.  This function is only available on the HTML5 platform."]
    #[doc = " This destroys any previously-created logger."]
    pub fn vnc_Logger_createBrowserLogger();
}
extern "C" {
    #[doc = " Destroys any previously created logger.  Without a logger, all log data is"]
    #[doc = " silently discarded."]
    pub fn vnc_Logger_destroyLogger();
}
