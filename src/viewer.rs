/* automatically generated by rust-bindgen 0.59.2 */

pub const vnc_true: u32 = 1;
pub const vnc_false: u32 = 0;
pub const vnc_success: u32 = 1;
pub const vnc_failure: u32 = 0;
#[doc = " @name Common primitive types */"]
pub type vnc_int8_t = ::std::os::raw::c_schar;
pub type vnc_int16_t = ::std::os::raw::c_short;
pub type vnc_int32_t = ::std::os::raw::c_int;
pub type vnc_int64_t = ::std::os::raw::c_longlong;
pub type vnc_uint8_t = ::std::os::raw::c_uchar;
pub type vnc_uint16_t = ::std::os::raw::c_ushort;
pub type vnc_uint31_t = ::std::os::raw::c_uint;
pub type vnc_uint32_t = ::std::os::raw::c_uint;
pub type vnc_uint64_t = ::std::os::raw::c_ulonglong;
#[doc = " @name Boolean type"]
#[doc = " @details Note that #vnc_true and #vnc_false are guaranteed to be defined as"]
#[doc = " 1 and 0 respectively in all future versions of the SDK.  There is no need to"]
#[doc = " explicitly reference these constants, unless you prefer that coding style."]
pub type vnc_bool_t = ::std::os::raw::c_int;
#[doc = " @name Status type"]
#[doc = " @details Note that #vnc_success and #vnc_failure are guaranteed to be defined"]
#[doc = " as 1 and 0 respectively in all future versions of the SDK.  There is no need"]
#[doc = " to explicitly reference these constants, unless you prefer that coding style;"]
#[doc = " either of these is acceptable:"]
#[doc = ""]
#[doc = " @code"]
#[doc = " if (!vnc_Logger_createFileLogger(\"logfile.txt\"))"]
#[doc = "     handleError();"]
#[doc = " @endcode"]
#[doc = ""]
#[doc = " or:"]
#[doc = " @code"]
#[doc = " if (vnc_Logger_createFileLogger(\"logfile.txt\") != vnc_success)"]
#[doc = "     handleError();"]
#[doc = " @endcode"]
#[doc = ""]
pub type vnc_status_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Connection {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_ConnectionHandler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_AnnotationManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_MessagingManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DisplayManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DataBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Server {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Viewer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_PixelFormat {
    _unused: [u8; 0],
}
pub type vnc_assert_int8_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int16_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int32_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int64_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint8_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint16_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint31_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint32_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint64_t = [::std::os::raw::c_char; 1usize];
pub const vnc_DummyEnum_vnc_DummyEnum1: vnc_DummyEnum = 0;
pub const vnc_DummyEnum_vnc_DummyEnum2: vnc_DummyEnum = 1;
pub type vnc_DummyEnum = ::std::os::raw::c_uint;
pub type vnc_assert_DummyEnum = [::std::os::raw::c_char; 1usize];
pub type VncAssertionHandler =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;
extern "C" {
    #[doc = " 32 bits per pixel stored as XXXXXXXXRRRRRRRRGGGGGGGGBBBBBBBB in most"]
    #[doc = "  significant to least significant bit order"]
    pub fn vnc_PixelFormat_rgb888() -> *const vnc_PixelFormat;
}
extern "C" {
    #[doc = " 32 bits per pixel stored as XXXXXXXXBBBBBBBBGGGGGGGGRRRRRRRR in most"]
    #[doc = "  significant to least significant bit order"]
    pub fn vnc_PixelFormat_bgr888() -> *const vnc_PixelFormat;
}
extern "C" {
    #[doc = " 16 bits per pixel stored as RRRRRGGGGGGBBBBB in most significant to least"]
    #[doc = "  significant bit order"]
    pub fn vnc_PixelFormat_rgb565() -> *const vnc_PixelFormat;
}
extern "C" {
    #[doc = " 16 bits per pixel stored as XRRRRRGGGGGBBBBB in most significant to least"]
    #[doc = "  significant bit order"]
    pub fn vnc_PixelFormat_rgb555() -> *const vnc_PixelFormat;
}
extern "C" {
    #[doc = " Gets the total number of bits per pixel."]
    pub fn vnc_PixelFormat_bpp(pf: *const vnc_PixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the number of significant bits that are used to store pixel data."]
    pub fn vnc_PixelFormat_depth(pf: *const vnc_PixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the maximum value for the red pixel value."]
    pub fn vnc_PixelFormat_redMax(pf: *const vnc_PixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the maximum value for the green pixel value."]
    pub fn vnc_PixelFormat_greenMax(pf: *const vnc_PixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the maximum value for the blue pixel value."]
    pub fn vnc_PixelFormat_blueMax(pf: *const vnc_PixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the number of bits the red pixel value is shifted."]
    pub fn vnc_PixelFormat_redShift(pf: *const vnc_PixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the number of bits the green pixel value is shifted."]
    pub fn vnc_PixelFormat_greenShift(pf: *const vnc_PixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the number of bits the blue pixel value is shifted."]
    pub fn vnc_PixelFormat_blueShift(pf: *const vnc_PixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a custom pixel format based on the given parameters."]
    #[doc = ""]
    #[doc = " @param bitsPerPixel The total number of bits per pixel (a multiple of eight)."]
    #[doc = " @param redMax The maximum value for the red pixel value."]
    #[doc = " @param greenMax The maximum value for the red pixel value."]
    #[doc = " @param blueMax The maximum value for the red pixel value."]
    #[doc = " @param redShift The number of bits the red pixel is shifted."]
    #[doc = " @param greenShift The number of bits the green pixel is shifted."]
    #[doc = " @param blueShift The number of bits the blue pixel is shifted."]
    pub fn vnc_PixelFormat_create(
        bitsPerPixel: ::std::os::raw::c_int,
        redMax: ::std::os::raw::c_int,
        greenMax: ::std::os::raw::c_int,
        blueMax: ::std::os::raw::c_int,
        redShift: ::std::os::raw::c_int,
        greenShift: ::std::os::raw::c_int,
        blueShift: ::std::os::raw::c_int,
    ) -> *mut vnc_PixelFormat;
}
extern "C" {
    #[doc = " Destroy a custom pixel format."]
    #[doc = ""]
    #[doc = " @param pf The pixel format object."]
    pub fn vnc_PixelFormat_destroy(pf: *mut vnc_PixelFormat);
}
extern "C" {
    #[doc = " Creates a data buffer containing a copy of the given data."]
    #[doc = ""]
    #[doc = " @param data A pointer to untyped data."]
    #[doc = " @param sizeBytes The size of the data."]
    #[doc = ""]
    #[doc = " @return Returns a new @ref vnc_DataBuffer on success, or NULL on"]
    #[doc = "     error.  If an error is returned, vnc_getLastError() can be used to get"]
    #[doc = "     the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     @p data is NULL and @p sizeBytes is non-zero"]
    pub fn vnc_DataBuffer_create(
        data: *const ::std::os::raw::c_void,
        sizeBytes: ::std::os::raw::c_int,
    ) -> *mut vnc_DataBuffer;
}
extern "C" {
    #[doc = " Gets the data contained in the buffer."]
    #[doc = ""]
    #[doc = " @param buffer The buffer."]
    #[doc = " @param bufferSize An optional output parameter used to return the size of the"]
    #[doc = "     data in the data buffer."]
    #[doc = ""]
    #[doc = " @return A pointer to the data stored in the data buffer, or NULL if the size"]
    #[doc = "     of the data buffer is zero."]
    pub fn vnc_DataBuffer_getData(
        buffer: *const vnc_DataBuffer,
        bufferSize: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Destroys the data buffer."]
    #[doc = ""]
    #[doc = " @param buffer The buffer."]
    pub fn vnc_DataBuffer_destroy(buffer: *mut vnc_DataBuffer);
}
extern "C" {
    #[doc = " Creates and returns a new viewer."]
    #[doc = ""]
    #[doc = " @return Returns a new @ref vnc_Viewer."]
    pub fn vnc_Viewer_create() -> *mut vnc_Viewer;
}
extern "C" {
    #[doc = " Destroys the viewer."]
    pub fn vnc_Viewer_destroy(viewer: *mut vnc_Viewer);
}
#[doc = " The viewer is not connected to a server."]
pub const vnc_Viewer_ConnectionStatus_vnc_Viewer_Disconnected: vnc_Viewer_ConnectionStatus = 0;
#[doc = " The viewer is negotiating a connection to a server (includes"]
#[doc = " authentication)."]
pub const vnc_Viewer_ConnectionStatus_vnc_Viewer_Connecting: vnc_Viewer_ConnectionStatus = 1;
#[doc = " The viewer is connected to a server."]
pub const vnc_Viewer_ConnectionStatus_vnc_Viewer_Connected: vnc_Viewer_ConnectionStatus = 2;
#[doc = " vnc_Viewer_disconnect() has been called but we've not yet disconnected"]
#[doc = " from the server."]
pub const vnc_Viewer_ConnectionStatus_vnc_Viewer_Disconnecting: vnc_Viewer_ConnectionStatus = 3;
#[doc = " Enumeration of connection statuses.  These are returned by"]
#[doc = " vnc_Viewer_getConnectionStatus() to query the status of the connection for"]
#[doc = " a given viewer."]
pub type vnc_Viewer_ConnectionStatus = ::std::os::raw::c_uint;
#[doc = " The disconnection message could be shown to the user.  This is set if the"]
#[doc = " server sent this flag with its disconnection message, or the viewer"]
#[doc = " disconnected due to an error."]
pub const vnc_Viewer_DisconnectFlags_vnc_Viewer_AlertUser: vnc_Viewer_DisconnectFlags = 1;
#[doc = " The connection has been broken, but a reconnection attempt may succeed."]
pub const vnc_Viewer_DisconnectFlags_vnc_Viewer_CanReconnect: vnc_Viewer_DisconnectFlags = 2;
#[doc = " Enumeration of disconnection flags."]
pub type vnc_Viewer_DisconnectFlags = ::std::os::raw::c_uint;
#[doc = " Callback receiving state-change notifications for a Viewer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Viewer_ConnectionCallback {
    #[doc = " Notification that is called when the viewer begins a connection attempt to"]
    #[doc = " the server.  This callback is optional."]
    #[doc = ""]
    #[doc = " When vnc_CloudConnector_connect() is called, the connecting callback will"]
    #[doc = " be invoked on the next turn of the event loop, so it is normally not useful"]
    #[doc = " to implement this callback, since the application's UI state can be updated"]
    #[doc = " straight away."]
    #[doc = ""]
    #[doc = " If however the viewer creates connections using a Cloud listener, then the"]
    #[doc = " connecting callback is essential to implement.  This is because each viewer"]
    #[doc = " object can only handle a single connection at a time, so it makes no sense"]
    #[doc = " to continue listening once the viewer has started handling a connection."]
    #[doc = " If a second connection comes in, the viewer will not be able to accept it"]
    #[doc = " and an error will be logged.  To stop listening, the Cloud listener should"]
    #[doc = " be destroyed from the connecting callback."]
    pub connecting: ::std::option::Option<
        unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void, viewer: *mut vnc_Viewer),
    >,
    #[doc = " Notification that is called when the viewer successfully connects to a"]
    #[doc = " server (after authentication).  This callback is optional."]
    pub connected: ::std::option::Option<
        unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void, viewer: *mut vnc_Viewer),
    >,
    #[doc = " Notification that is called when the viewer disconnects from the server."]
    #[doc = " This callback is optional."]
    #[doc = ""]
    #[doc = " @param reason See vnc_Viewer_getDisconnectReason() for possible"]
    #[doc = "     disconnection reasons."]
    #[doc = " @param flags Zero or more of the @ref vnc_Viewer_DisconnectFlags flags."]
    pub disconnected: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            viewer: *mut vnc_Viewer,
            reason: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout_vnc_Viewer_ConnectionCallback() {
    assert_eq!(
        ::std::mem::size_of::<vnc_Viewer_ConnectionCallback>(),
        24usize,
        concat!("Size of: ", stringify!(vnc_Viewer_ConnectionCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<vnc_Viewer_ConnectionCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(vnc_Viewer_ConnectionCallback))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Viewer_ConnectionCallback>())).connecting as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Viewer_ConnectionCallback),
            "::",
            stringify!(connecting)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Viewer_ConnectionCallback>())).connected as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Viewer_ConnectionCallback),
            "::",
            stringify!(connected)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Viewer_ConnectionCallback>())).disconnected as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Viewer_ConnectionCallback),
            "::",
            stringify!(disconnected)
        )
    );
}
extern "C" {
    #[doc = " Sets the callbacks for the Viewer to call when various events occur during"]
    #[doc = " its lifetime."]
    #[doc = ""]
    #[doc = " @param callback The new connection callback."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     The callback is invalid"]
    pub fn vnc_Viewer_setConnectionCallback(
        viewer: *mut vnc_Viewer,
        callback: *const vnc_Viewer_ConnectionCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Returns the viewer's @ref vnc_ConnectionHandler for accepting connections."]
    #[doc = " The connection handler must not be used after the viewer has been destroyed;"]
    #[doc = " any Cloud listener using this viewer must be destroyed before the viewer"]
    #[doc = " itself."]
    pub fn vnc_Viewer_getConnectionHandler(viewer: *mut vnc_Viewer) -> *mut vnc_ConnectionHandler;
}
extern "C" {
    #[doc = " Returns the status of the viewer's connection.  See"]
    #[doc = " vnc_Viewer_ConnectionStatus() for possible values."]
    pub fn vnc_Viewer_getConnectionStatus(viewer: *mut vnc_Viewer) -> vnc_Viewer_ConnectionStatus;
}
extern "C" {
    #[doc = " Returns the address of the viewer's server.  The format of the string is"]
    #[doc = " <tt>[vnccloud:\\<cloud-address\\>]</tt> for VNC Cloud addresses.  The string is"]
    #[doc = " only guaranteed to be valid until the next call to any SDK function."]
    #[doc = ""]
    #[doc = " @param viewer The Viewer."]
    #[doc = ""]
    #[doc = " @return The address as a NULL-terminated string, or NULL in the case of an"]
    #[doc = "     error, in which case call vnc_getLastError() to get the error code."]
    #[doc = ""]
    #[doc = " @retval UnexpectedCall"]
    #[doc = "     The viewer is not connected"]
    pub fn vnc_Viewer_getPeerAddress(viewer: *mut vnc_Viewer) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Disconnects this viewer from the server.  Sets the disconnection reason to"]
    #[doc = " @c ViewerClosedConnection.  This method does nothing if the viewer is not"]
    #[doc = " currently connected.  Once disconnected you may subsequently connect the"]
    #[doc = " viewer to the same server again."]
    #[doc = ""]
    #[doc = " @param viewer The Viewer."]
    #[doc = ""]
    #[doc = " @return #vnc_success."]
    pub fn vnc_Viewer_disconnect(viewer: *mut vnc_Viewer) -> vnc_status_t;
}
extern "C" {
    #[doc = " Returns a string ID representing the reason for the last viewer"]
    #[doc = " disconnection.  Returns NULL if there have not been any disconnections, or"]
    #[doc = " the viewer has been connected again since the last disconnection."]
    #[doc = ""]
    #[doc = " Some of the connection reasons are sent by the server to explain the reason"]
    #[doc = " for ending the connection.  These disconnection reasons are free-form and a"]
    #[doc = " third-party server may send reasons not on this list.  To help diagnosing the"]
    #[doc = " cause of the disconnection, vnc_Viewer_getDisconnectMessage() can be used to"]
    #[doc = " get a human-readable message sent by the server which explains the reason."]
    #[doc = " Possible reasons sent by the server are:"]
    #[doc = ""]
    #[doc = "  - @c AuthFailure: the viewer user did not provide appropriate credentials"]
    #[doc = "  - @c ConnTimeout: the connection reached its maximum duration"]
    #[doc = "  - @c IdleTimeout: the connection timed out after no activity.  This can"]
    #[doc = "    happen when the connection is being established if the requested"]
    #[doc = "    credentials are not sent within a reasonable amount of time."]
    #[doc = "  - @c ServerShutdown: the server process has shut down (the disconnection"]
    #[doc = "    message may include further details)"]
    #[doc = "  - @c ServerSuspended: the server machine is going in suspend mode"]
    #[doc = "  - @c TooManySecFail: too many security failures have occurred in a short"]
    #[doc = "    space of time, so the server has rejected the connection"]
    #[doc = "  - @c UserSwitch: the server machine is switching desktops, causing a"]
    #[doc = "    temporary disconnection."]
    #[doc = ""]
    #[doc = " In addition, @c ServerClosedConnection indicates a normal disconnection"]
    #[doc = " initiated by the server."]
    #[doc = ""]
    #[doc = " Some of the reasons occur when the viewer initiates the disconnection, in"]
    #[doc = " which case the list of possible disconnection reasons is known in advance."]
    #[doc = " Possible reasons known to the viewer are:"]
    #[doc = ""]
    #[doc = "  - @c CloudAuthenticationFailed: the Cloud password or address is incorrect"]
    #[doc = "  - @c CloudConnectionRefused: the local Cloud address does not have"]
    #[doc = "    permission to connect to the server's Cloud address"]
    #[doc = "  - @c CloudTargetNotFound: there is no server listening on the Cloud address"]
    #[doc = "  - @c DataStoreError: there is no data store"]
    #[doc = "  - @c ViewerCancelledAuthentication: authentication was cancelled by calling"]
    #[doc = "    vnc_Viewer_sendAuthenticationResponse() with @c ok as #vnc_false"]
    #[doc = "  - @c ViewerClosedConnection: the connection was closed by calling"]
    #[doc = "    vnc_Viewer_disconnect()"]
    #[doc = "  - @c ViewerRejectedConnection: the connection was rejected by the viewer not"]
    #[doc = "    accepting the connection security or peer identity via the"]
    #[doc = "    vnc_Viewer_PeerVerificationCallback::verifyPeer callback."]
    #[doc = ""]
    #[doc = " Finally, some of the reasons can occur both from the viewer or server, or"]
    #[doc = " somewhere in between! Possible reasons are:"]
    #[doc = ""]
    #[doc = "  - @c ConnectivityError: a connection to the server could not be established,"]
    #[doc = "    or there was an error reading or writing to the peer"]
    #[doc = "  - @c ConnectionDropped: the connection was closed at the transport level,"]
    #[doc = "    with no closing handshake"]
    #[doc = "  - @c ConnectionNegotiationError: the connection could not be established due"]
    #[doc = "    to an error during negotiation with the peer; consult the debug logs for"]
    #[doc = "    more information."]
    #[doc = "  - @c ConnectionResolveError: a specified Direct TCP hostname or IP address"]
    #[doc = "    is malformed, or is not legitimate (e.g. DNS lookup fails), or the"]
    #[doc = "    resolver service cannot be reached; consult the debug logs for more"]
    #[doc = "    information."]
    #[doc = ""]
    #[doc = " If cause is not recognized, the reason will be @c Unknown; please consult the"]
    #[doc = " debug logs for more information on the underlying cause of the disconnection."]
    pub fn vnc_Viewer_getDisconnectReason(viewer: *mut vnc_Viewer)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a human-readable message sent by the server for the last"]
    #[doc = " disconnection, or NULL if the last disconnection was not initiated by the"]
    #[doc = " server.  If the reason for the disconnection originated at the viewer end"]
    #[doc = " then there is no message, since the reason string comes from a known set of"]
    #[doc = " possibilities."]
    pub fn vnc_Viewer_getDisconnectMessage(
        viewer: *mut vnc_Viewer,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " Callback receiving framebuffer event notifications for a Viewer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Viewer_FramebufferCallback {
    #[doc = " Notification that the server's framebuffer size has changed.  You may"]
    #[doc = " choose to resize the viewer framebuffer by calling vnc_Viewer_setViewerFb()"]
    #[doc = " from this function, for example, to maintain a consistent aspect ratio."]
    #[doc = " This callback is optional."]
    #[doc = ""]
    #[doc = " @param w The width of the server's framebuffer."]
    #[doc = " @param h The height of the server's framebuffer."]
    pub serverFbSizeChanged: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            viewer: *mut vnc_Viewer,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Notification that the given rectangle of the viewer's framebuffer has been"]
    #[doc = " updated with new pixel data.  This callback is optional."]
    pub viewerFbUpdated: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            viewer: *mut vnc_Viewer,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout_vnc_Viewer_FramebufferCallback() {
    assert_eq!(
        ::std::mem::size_of::<vnc_Viewer_FramebufferCallback>(),
        16usize,
        concat!("Size of: ", stringify!(vnc_Viewer_FramebufferCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<vnc_Viewer_FramebufferCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(vnc_Viewer_FramebufferCallback))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Viewer_FramebufferCallback>())).serverFbSizeChanged
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Viewer_FramebufferCallback),
            "::",
            stringify!(serverFbSizeChanged)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Viewer_FramebufferCallback>())).viewerFbUpdated as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Viewer_FramebufferCallback),
            "::",
            stringify!(viewerFbUpdated)
        )
    );
}
extern "C" {
    #[doc = " Sets the framebuffer callback for this viewer."]
    #[doc = ""]
    #[doc = " @param viewer The Viewer."]
    #[doc = " @param callback The new framebuffer callback."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     The callback is invalid"]
    pub fn vnc_Viewer_setFramebufferCallback(
        viewer: *mut vnc_Viewer,
        callback: *const vnc_Viewer_FramebufferCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Sets the viewer framebuffer.  The pixel data received from the server will"]
    #[doc = " be rendered into the buffer in the given pixel format, scaled to fit the"]
    #[doc = " given size, and with the given stride."]
    #[doc = ""]
    #[doc = " @param viewer The Viewer."]
    #[doc = " @param pixels Pointer to the framebuffer to receive pixel data.  The buffer"]
    #[doc = "     must be large enough, i.e.  stride * height pixels.  Alternatively, pass"]
    #[doc = "     NULL for a buffer owned by the SDK to be allocated for you."]
    #[doc = " @param pixelsBytes The size in bytes of the buffer pointed to by @p pixels"]
    #[doc = "     (ignored if @p pixels is NULL)."]
    #[doc = " @param pf Pixel format for the pixel data."]
    #[doc = " @param width The width of the framebuffer."]
    #[doc = " @param height The height of the framebuffer"]
    #[doc = " @param stride The stride of the framebuffer, i.e.  the number of pixels from"]
    #[doc = "     the start of one row to the next.  If specified as zero then the width is"]
    #[doc = "     used.  Note that this is specified in terms of pixels, not bytes."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     @p width or @p height is zero or negative, the stride is invalid, or the"]
    #[doc = "     @p pixels buffer is not large enough"]
    pub fn vnc_Viewer_setViewerFb(
        viewer: *mut vnc_Viewer,
        pixels: *mut ::std::os::raw::c_void,
        pixelsBytes: ::std::os::raw::c_int,
        pf: *const vnc_PixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        stride: ::std::os::raw::c_int,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Gets the width of the viewer framebuffer."]
    pub fn vnc_Viewer_getViewerFbWidth(viewer: *mut vnc_Viewer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the height of the viewer framebuffer."]
    pub fn vnc_Viewer_getViewerFbHeight(viewer: *mut vnc_Viewer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the pixel format of the viewer framebuffer."]
    pub fn vnc_Viewer_getViewerFbPixelFormat(viewer: *mut vnc_Viewer) -> *const vnc_PixelFormat;
}
extern "C" {
    #[doc = " Returns the viewer framebuffer data for the given rectangle.  The returned"]
    #[doc = " object is valid until the next call to vnc_Viewer_getViewerFbData() or"]
    #[doc = " vnc_Viewer_setViewerFb().  The stride of the data is given by"]
    #[doc = " vnc_Viewer_getViewerFbStride()."]
    #[doc = ""]
    #[doc = " @param viewer The Viewer."]
    #[doc = " @param x The left edge of the rectangle."]
    #[doc = " @param y The top edge of the rectangle."]
    #[doc = " @param w The width of the rectangle."]
    #[doc = " @param h The height of the rectangle."]
    #[doc = ""]
    #[doc = " @return Returns the data buffer, or NULL on error, in which case call"]
    #[doc = "     vnc_getLastError() to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     @c w or @c h are zero or negative, or the rectangle is not fully"]
    #[doc = "     contained within the framebuffer"]
    pub fn vnc_Viewer_getViewerFbData(
        viewer: *mut vnc_Viewer,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    ) -> *const vnc_DataBuffer;
}
extern "C" {
    #[doc = " Returns the stride of the viewer framebuffer data in pixels, that is, the"]
    #[doc = " number of pixels from the start of each row until the start of the next."]
    #[doc = ""]
    #[doc = " @param viewer The Viewer."]
    #[doc = ""]
    #[doc = " @return The stride in pixels."]
    pub fn vnc_Viewer_getViewerFbStride(viewer: *mut vnc_Viewer) -> ::std::os::raw::c_int;
}
#[doc = " Callback receiving server event notifications for a Viewer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Viewer_ServerEventCallback {
    #[doc = " Notification that the server's clipboard contains new text.  This"]
    #[doc = " callback is optional."]
    #[doc = ""]
    #[doc = " @param text The UTF-8 encoded text."]
    pub serverClipboardTextChanged: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            viewer: *mut vnc_Viewer,
            text: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " Notification that the server's friendly name has changed.  This callback is"]
    #[doc = " optional."]
    #[doc = ""]
    #[doc = " @param name The UTF-8 encoded name."]
    pub serverFriendlyNameChanged: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            viewer: *mut vnc_Viewer,
            name: *const ::std::os::raw::c_char,
        ),
    >,
}
#[test]
fn bindgen_test_layout_vnc_Viewer_ServerEventCallback() {
    assert_eq!(
        ::std::mem::size_of::<vnc_Viewer_ServerEventCallback>(),
        16usize,
        concat!("Size of: ", stringify!(vnc_Viewer_ServerEventCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<vnc_Viewer_ServerEventCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(vnc_Viewer_ServerEventCallback))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Viewer_ServerEventCallback>())).serverClipboardTextChanged
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Viewer_ServerEventCallback),
            "::",
            stringify!(serverClipboardTextChanged)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Viewer_ServerEventCallback>())).serverFriendlyNameChanged
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Viewer_ServerEventCallback),
            "::",
            stringify!(serverFriendlyNameChanged)
        )
    );
}
extern "C" {
    #[doc = " Sets the server event callback for this viewer."]
    #[doc = ""]
    #[doc = " @param viewer The Viewer."]
    #[doc = " @param callback The new server event callback."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     The callback is invalid"]
    pub fn vnc_Viewer_setServerEventCallback(
        viewer: *mut vnc_Viewer,
        callback: *const vnc_Viewer_ServerEventCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Copies the given text to the server's clipboard."]
    #[doc = ""]
    #[doc = " @param viewer The Viewer."]
    #[doc = " @param text The UTF-8 encoded text."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     @p text is NULL"]
    pub fn vnc_Viewer_sendClipboardText(
        viewer: *mut vnc_Viewer,
        text: *const ::std::os::raw::c_char,
    ) -> vnc_status_t;
}
#[doc = " The logical left mouse button."]
pub const vnc_Viewer_MouseButton_vnc_Viewer_MouseButtonLeft: vnc_Viewer_MouseButton = 1;
#[doc = " The logical middle mouse button."]
pub const vnc_Viewer_MouseButton_vnc_Viewer_MouseButtonMiddle: vnc_Viewer_MouseButton = 2;
#[doc = " The logical right mouse button."]
pub const vnc_Viewer_MouseButton_vnc_Viewer_MouseButtonRight: vnc_Viewer_MouseButton = 4;
#[doc = " Enumeration of mouse buttons.  Here \"left\" and \"right\" refer to logical"]
#[doc = " buttons, which may not correspond to the physical orientation of the buttons"]
#[doc = " if using a left-handed mouse."]
pub type vnc_Viewer_MouseButton = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Sends a pointer event to the server.  If @p rel is #vnc_false then @p x and"]
    #[doc = " @p y give the absolute position of the mouse pointer in viewer framebuffer"]
    #[doc = " coordinates with 0,0 at the top-left of the framebuffer.  If @p rel is"]
    #[doc = " #vnc_true then @p x and @p y give the relative movement delta in \"mickeys\"."]
    #[doc = ""]
    #[doc = " Attempting to use coordinates outside of the viewer framebuffer will result in"]
    #[doc = " an undefined behaviour."]
    #[doc = ""]
    #[doc = " @param viewer The Viewer."]
    #[doc = " @param x The X coordinate."]
    #[doc = " @param y The Y coordinate."]
    #[doc = " @param buttonState A bitmask containing zero or more of"]
    #[doc = "     @ref vnc_Viewer_MouseButtonLeft, @ref vnc_Viewer_MouseButtonMiddle and"]
    #[doc = "     @ref vnc_Viewer_MouseButtonRight, indicating which buttons are down, if"]
    #[doc = "     any."]
    #[doc = " @param rel Whether the event is relative or absolute."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     @p buttonState is invalid"]
    pub fn vnc_Viewer_sendPointerEvent(
        viewer: *mut vnc_Viewer,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        buttonState: ::std::os::raw::c_int,
        rel: vnc_bool_t,
    ) -> vnc_status_t;
}
#[doc = " The horizontal scroll wheel."]
pub const vnc_Viewer_MouseWheel_vnc_Viewer_MouseWheelHorizontal: vnc_Viewer_MouseWheel = 1;
#[doc = " The vertical scroll wheel."]
pub const vnc_Viewer_MouseWheel_vnc_Viewer_MouseWheelVertical: vnc_Viewer_MouseWheel = 2;
#[doc = " Enumeration of mouse wheel directions."]
pub type vnc_Viewer_MouseWheel = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Sends a scroll wheel event to the server."]
    #[doc = ""]
    #[doc = " @param viewer The Viewer."]
    #[doc = " @param delta The number of scroll wheel \"ticks\".  You may need to reduce the"]
    #[doc = "     value provided by a high-resolution scroll device to get appropriate"]
    #[doc = "     behavior (for example, one tick is equivalent to a distance of 120 in the"]
    #[doc = "     Win32 API).  If @p delta is negative then the movement is upwards or"]
    #[doc = "     towards the left, if positive then the movement is downwards or towards"]
    #[doc = "     the right."]
    #[doc = " @param axis The scroll axis (either @ref vnc_Viewer_MouseWheelHorizontal or"]
    #[doc = "     @ref vnc_Viewer_MouseWheelVertical)."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     @p axis is invalid"]
    pub fn vnc_Viewer_sendScrollEvent(
        viewer: *mut vnc_Viewer,
        delta: ::std::os::raw::c_int,
        axis: vnc_Viewer_MouseWheel,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Sends a key down (press) event to the server."]
    #[doc = ""]
    #[doc = " @param viewer The Viewer."]
    #[doc = " @param keysym The keysym value representing the meaning of the pressed key."]
    #[doc = "   Use vnc_unicodeToKeysym() to convert a unicode character to a keysym.  See"]
    #[doc = "   vnc/Keyboard.h for common keysym values for non-character keys."]
    #[doc = " @param keyCode An integer code representing the physical key which has been"]
    #[doc = "   pressed.  The SDK only uses this to match up the corresponding call to"]
    #[doc = "   vnc_Viewer_sendKeyUp()."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    pub fn vnc_Viewer_sendKeyDown(
        viewer: *mut vnc_Viewer,
        keysym: vnc_uint31_t,
        keyCode: ::std::os::raw::c_int,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Sends a key up (release) event to the server."]
    #[doc = ""]
    #[doc = " @param viewer The Viewer."]
    #[doc = " @param keyCode An integer code representing the physical key which has been"]
    #[doc = "   released.  If there was no prior call to vnc_Viewer_sendKeyDown() for this"]
    #[doc = "   @p keyCode, it is simply ignored."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    pub fn vnc_Viewer_sendKeyUp(
        viewer: *mut vnc_Viewer,
        keyCode: ::std::os::raw::c_int,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Send key up events for all currently pressed keys.  Typically you call this"]
    #[doc = " when the viewer loses keyboard focus."]
    #[doc = ""]
    #[doc = " @param viewer The Viewer."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    pub fn vnc_Viewer_releaseAllKeys(viewer: *mut vnc_Viewer) -> vnc_status_t;
}
#[doc = " Callback receiving requests for authentication for a Viewer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Viewer_AuthenticationCallback {
    #[doc = " Request for a username and/or password.  Implementors should reply with a"]
    #[doc = " username and/or password either immediately or later, by calling"]
    #[doc = " vnc_Viewer_sendAuthenticationResponse().  This callback function is"]
    #[doc = " required if using a @ref vnc_Viewer_AuthenticationCallback."]
    #[doc = " This callback will not be triggered if no credentials are required."]
    #[doc = ""]
    #[doc = " @param needUser Whether a username must be supplied."]
    #[doc = " @param needPasswd Whether a password must be supplied."]
    pub requestUserCredentials: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            viewer: *mut vnc_Viewer,
            needUser: vnc_bool_t,
            needPasswd: vnc_bool_t,
        ),
    >,
    #[doc = " Notification to cancel a username and/or password request.  This can happen"]
    #[doc = " if the server closes the connection while the Viewer is waiting for the"]
    #[doc = " user to provide a username/password.  This callback is optional."]
    pub cancelUserCredentialsRequest: ::std::option::Option<
        unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void, viewer: *mut vnc_Viewer),
    >,
}
#[test]
fn bindgen_test_layout_vnc_Viewer_AuthenticationCallback() {
    assert_eq!(
        ::std::mem::size_of::<vnc_Viewer_AuthenticationCallback>(),
        16usize,
        concat!("Size of: ", stringify!(vnc_Viewer_AuthenticationCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<vnc_Viewer_AuthenticationCallback>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(vnc_Viewer_AuthenticationCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Viewer_AuthenticationCallback>())).requestUserCredentials
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Viewer_AuthenticationCallback),
            "::",
            stringify!(requestUserCredentials)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Viewer_AuthenticationCallback>()))
                .cancelUserCredentialsRequest as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Viewer_AuthenticationCallback),
            "::",
            stringify!(cancelUserCredentialsRequest)
        )
    );
}
extern "C" {
    #[doc = " Sets the callback to be called when a username and/or password is required."]
    #[doc = " If these are not provided then UI will be rendered into the framebuffer"]
    #[doc = " asking the user to provide the required information."]
    #[doc = ""]
    #[doc = " @param viewer The Viewer."]
    #[doc = " @param callback The new authentication callback."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     The vnc_Viewer_AuthenticationCallback::requestUserCredentials callback is"]
    #[doc = "     NULL"]
    pub fn vnc_Viewer_setAuthenticationCallback(
        viewer: *mut vnc_Viewer,
        callback: *const vnc_Viewer_AuthenticationCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Provides the SDK with the result of a username/password request."]
    #[doc = ""]
    #[doc = " @param viewer The Viewer."]
    #[doc = " @param ok This should be #vnc_false if the user cancelled the password"]
    #[doc = "     dialog."]
    #[doc = " @param user This must not be NULL if @p needUser was @p vnc_true in the"]
    #[doc = "     username/password request, otherwise it is ignored."]
    #[doc = " @param passwd This must not be NULL if @p needPasswd was @p vnc_true in the"]
    #[doc = "     username/password request, otherwise it is ignored."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval UnexpectedCall"]
    #[doc = "     The session is not waiting for a username/password response"]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     @c user or @c passwd was requested but is NULL"]
    pub fn vnc_Viewer_sendAuthenticationResponse(
        viewer: *mut vnc_Viewer,
        ok: vnc_bool_t,
        user: *const ::std::os::raw::c_char,
        passwd: *const ::std::os::raw::c_char,
    ) -> vnc_status_t;
}
#[doc = " Callback receiving verification requests to check the peer's identity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Viewer_PeerVerificationCallback {
    #[doc = " Request to verify the identity of the peer (the server).  Implementors"]
    #[doc = " should respond by calling vnc_Viewer_sendPeerVerificationResponse().  This"]
    #[doc = " callback function is required if using a"]
    #[doc = " @ref vnc_Viewer_PeerVerificationCallback."]
    #[doc = ""]
    #[doc = " Apart from cancelPeerVerification, no further callbacks (such as"]
    #[doc = " disconnected) will be issued for this connection until peer verification"]
    #[doc = " has been completed succesfully."]
    #[doc = ""]
    #[doc = " @param hexFingerprint The hash of the server's fingerprint, as a string of"]
    #[doc = "     hexadecimal digits."]
    #[doc = " @param catchphraseFingerprint The hash of the server's fingerprint, as a"]
    #[doc = "     catchphrase."]
    #[doc = " @param serverRsaPublic The server's public key, in the format returned by"]
    #[doc = "     vnc_RsaKey_getDetails()."]
    pub verifyPeer: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            viewer: *mut vnc_Viewer,
            hexFingerprint: *const ::std::os::raw::c_char,
            catchphraseFingerprint: *const ::std::os::raw::c_char,
            serverRsaPublic: *const vnc_DataBuffer,
        ),
    >,
    #[doc = " Notification to cancel a prior request for peer verification.  This can"]
    #[doc = " happen if the server closes the connection while peer verification is in"]
    #[doc = " progress.  This callback is optional."]
    pub cancelPeerVerification: ::std::option::Option<
        unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void, viewer: *mut vnc_Viewer),
    >,
}
#[test]
fn bindgen_test_layout_vnc_Viewer_PeerVerificationCallback() {
    assert_eq!(
        ::std::mem::size_of::<vnc_Viewer_PeerVerificationCallback>(),
        16usize,
        concat!("Size of: ", stringify!(vnc_Viewer_PeerVerificationCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<vnc_Viewer_PeerVerificationCallback>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(vnc_Viewer_PeerVerificationCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Viewer_PeerVerificationCallback>())).verifyPeer as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Viewer_PeerVerificationCallback),
            "::",
            stringify!(verifyPeer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_Viewer_PeerVerificationCallback>())).cancelPeerVerification
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_Viewer_PeerVerificationCallback),
            "::",
            stringify!(cancelPeerVerification)
        )
    );
}
extern "C" {
    #[doc = " Sets the callbacks to be called to verify the identity of the peer (server)."]
    #[doc = ""]
    #[doc = " If these are not provided for a VNC Cloud connection, the connection will"]
    #[doc = " continue regardless, since VNC Cloud automatically verifies peer identities"]
    #[doc = " for the connecting user. This check is for peace of mind only, and likely"]
    #[doc = " only to be useful if you have out-of-band access to a list of all potential"]
    #[doc = " Server identities."]
    #[doc = ""]
    #[doc = " If these are not provided for a Direct TCP connection, on the other hand, an"]
    #[doc = " identity verification dialog will automatically be displayed (rendered"]
    #[doc = " into the framebuffer), since the connecting user really should consider the"]
    #[doc = " risk of connecting to a MITM or other malicious entity."]
    #[doc = ""]
    #[doc = " @param viewer The Viewer."]
    #[doc = " @param callback The new peer verification callback."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     The vnc_Viewer_PeerVerificationCallback::verifyPeer callback is NULL"]
    pub fn vnc_Viewer_setPeerVerificationCallback(
        viewer: *mut vnc_Viewer,
        callback: *const vnc_Viewer_PeerVerificationCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Provides the SDK with the response to the"]
    #[doc = " vnc_Viewer_PeerVerificationCallback::verifyPeer request."]
    #[doc = ""]
    #[doc = " @param viewer The Viewer."]
    #[doc = " @param ok #vnc_true if the connection is approved, #vnc_false if it should"]
    #[doc = "    be rejected."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval UnexpectedCall"]
    #[doc = "     No peer verification is in progress"]
    pub fn vnc_Viewer_sendPeerVerificationResponse(
        viewer: *mut vnc_Viewer,
        ok: vnc_bool_t,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Enables receipt of audio from the Server by the Viewer. The audio stream"]
    #[doc = " will be automatically negotiated with the peer endpoint, if possible, and"]
    #[doc = " any received audio data will be played back via the device's default audio"]
    #[doc = " mixer."]
    #[doc = " By default, this is disabled and no audio channel will be negotiated."]
    #[doc = ""]
    #[doc = " @param viewer The Viewer."]
    #[doc = " @param enable #vnc_true to enable audio playback, #vnc_false to disable."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval PeerNotSupported"]
    #[doc = "     The peer endpoint does not support audio"]
    #[doc = ""]
    #[doc = " @retval NotSupported"]
    #[doc = "     This platform does not support audio"]
    #[doc = ""]
    #[doc = " @since 1.9"]
    pub fn vnc_Viewer_enableAudio(viewer: *mut vnc_Viewer, enable: vnc_bool_t) -> vnc_status_t;
}
extern "C" {
    #[doc = " Obtains the Viewer's @ref vnc_AnnotationManager for handling annotation"]
    #[doc = " operations."]
    #[doc = ""]
    #[doc = " @param viewer The current Viewer."]
    #[doc = ""]
    #[doc = " @return A @ref vnc_AnnotationManager, valid for the lifetime of the Viewer."]
    #[doc = ""]
    #[doc = " @since 1.4"]
    pub fn vnc_Viewer_getAnnotationManager(viewer: *mut vnc_Viewer) -> *mut vnc_AnnotationManager;
}
#[doc = " Auto quality means that the viewer selects an appropriate encoding and"]
#[doc = " colour level based on its own line speed estimate."]
pub const vnc_Viewer_PictureQuality_vnc_Viewer_PictureQuality_Auto: vnc_Viewer_PictureQuality = 0;
#[doc = " Auto quality means that the viewer selects an appropriate encoding and"]
#[doc = " colour level based on its own line speed estimate."]
pub const vnc_Viewer_PictureQuality_vnc_Viewer_PictureQuality_High: vnc_Viewer_PictureQuality = 1;
#[doc = " Auto quality means that the viewer selects an appropriate encoding and"]
#[doc = " colour level based on its own line speed estimate."]
pub const vnc_Viewer_PictureQuality_vnc_Viewer_PictureQuality_Medium: vnc_Viewer_PictureQuality = 2;
#[doc = " Auto quality means that the viewer selects an appropriate encoding and"]
#[doc = " colour level based on its own line speed estimate."]
pub const vnc_Viewer_PictureQuality_vnc_Viewer_PictureQuality_Low: vnc_Viewer_PictureQuality = 3;
#[doc = " Enumeration of picture quality levels."]
pub type vnc_Viewer_PictureQuality = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Returns the viewer's current picture quality."]
    #[doc = ""]
    #[doc = " This returns the actual picture quality in use if the viewer is connected,"]
    #[doc = " or the last value set otherwise."]
    pub fn vnc_Viewer_getPictureQuality(viewer: *mut vnc_Viewer) -> vnc_Viewer_PictureQuality;
}
extern "C" {
    #[doc = " Sets the desired picture quality of the session from the range of options"]
    #[doc = " enumerated by @ref vnc_Viewer_PictureQuality."]
    #[doc = ""]
    #[doc = " @param viewer The current Viewer."]
    #[doc = " @param quality The new picture quality."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     The picture quality is invalid"]
    pub fn vnc_Viewer_setPictureQuality(
        viewer: *mut vnc_Viewer,
        quality: vnc_Viewer_PictureQuality,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Obtains the Viewer's Messaging Manager for handling messaging"]
    pub fn vnc_Viewer_getMessagingManager(viewer: *mut vnc_Viewer) -> *mut vnc_MessagingManager;
}
#[doc = " Use strong encryption.  This is the default."]
pub const vnc_Viewer_EncryptionLevel_vnc_Viewer_EncryptionLevel_Default:
    vnc_Viewer_EncryptionLevel = 0;
#[doc = " Use the strongest available encryption, possibly at the cost of speed."]
pub const vnc_Viewer_EncryptionLevel_vnc_Viewer_EncryptionLevel_Maximum:
    vnc_Viewer_EncryptionLevel = 1;
#[doc = " Respect the server's choice of encryption level. This means the viewer"]
#[doc = " will allow connections to third-party servers, but also represents the"]
#[doc = " weakest security, and may open the user up to man-in-the-middle type"]
#[doc = " attacks. Use with caution."]
#[doc = " Note: to enable this feature, you will need a Third Party Connectivity"]
#[doc = " Add-on code - contact RealVNC for more information."]
pub const vnc_Viewer_EncryptionLevel_vnc_Viewer_EncryptionLevel_Server: vnc_Viewer_EncryptionLevel =
    255;
#[doc = " Enumeration of encryption levels."]
#[doc = ""]
#[doc = " @see vnc_Viewer_setEncryptionLevel()"]
pub type vnc_Viewer_EncryptionLevel = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Sets the desired encryption level of the session from the range of options"]
    #[doc = " enumerated by @ref vnc_Viewer_EncryptionLevel."]
    #[doc = ""]
    #[doc = " This will not affect the encryption level of established connections."]
    #[doc = ""]
    #[doc = " If a Viewer and Server select different encryption levels, connections"]
    #[doc = " between them take place at the higher of their selected levels."]
    #[doc = ""]
    #[doc = " @param viewer The current Viewer."]
    #[doc = " @param level The new encryption level."]
    #[doc = ""]
    #[doc = " @return #vnc_success or #vnc_failure, in which case call vnc_getLastError()"]
    #[doc = "     to get the error code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     The encryption level is invalid"]
    pub fn vnc_Viewer_setEncryptionLevel(
        viewer: *mut vnc_Viewer,
        level: vnc_Viewer_EncryptionLevel,
    ) -> vnc_status_t;
}
extern "C" {
    #[doc = " Returns the Viewer's current encryption level."]
    #[doc = ""]
    #[doc = " This returns the actual encryption level in use if the Viewer is connected,"]
    #[doc = " or the last value set otherwise."]
    pub fn vnc_Viewer_getEncryptionLevel(viewer: *mut vnc_Viewer) -> vnc_Viewer_EncryptionLevel;
}
extern "C" {
    #[doc = " Obtains the Viewer's @ref vnc_DisplayManager, for managing the list of"]
    #[doc = " displays made available by the Server to the Viewer."]
    #[doc = ""]
    #[doc = " @param viewer The current Viewer."]
    #[doc = " @return A @ref vnc_DisplayManager or NULL on error, in which case"]
    #[doc = "     call vnc_getLastError() to get the error code."]
    #[doc = ""]
    #[doc = " @retval NotSupported"]
    #[doc = "     Display management is not supported on the Server's platform."]
    #[doc = ""]
    #[doc = " @since 1.8.0"]
    pub fn vnc_Viewer_getDisplayManager(viewer: *mut vnc_Viewer) -> *mut vnc_DisplayManager;
}
