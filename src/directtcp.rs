/* automatically generated by rust-bindgen 0.59.2 */

pub const vnc_true: u32 = 1;
pub const vnc_false: u32 = 0;
pub const vnc_success: u32 = 1;
pub const vnc_failure: u32 = 0;
pub const VNC_DIRECT_TCP_DEFAULT_PORT: u32 = 5900;
#[doc = " @name Common primitive types */"]
pub type vnc_int8_t = ::std::os::raw::c_schar;
pub type vnc_int16_t = ::std::os::raw::c_short;
pub type vnc_int32_t = ::std::os::raw::c_int;
pub type vnc_int64_t = ::std::os::raw::c_longlong;
pub type vnc_uint8_t = ::std::os::raw::c_uchar;
pub type vnc_uint16_t = ::std::os::raw::c_ushort;
pub type vnc_uint31_t = ::std::os::raw::c_uint;
pub type vnc_uint32_t = ::std::os::raw::c_uint;
pub type vnc_uint64_t = ::std::os::raw::c_ulonglong;
#[doc = " @name Boolean type"]
#[doc = " @details Note that #vnc_true and #vnc_false are guaranteed to be defined as"]
#[doc = " 1 and 0 respectively in all future versions of the SDK.  There is no need to"]
#[doc = " explicitly reference these constants, unless you prefer that coding style."]
pub type vnc_bool_t = ::std::os::raw::c_int;
#[doc = " @name Status type"]
#[doc = " @details Note that #vnc_success and #vnc_failure are guaranteed to be defined"]
#[doc = " as 1 and 0 respectively in all future versions of the SDK.  There is no need"]
#[doc = " to explicitly reference these constants, unless you prefer that coding style;"]
#[doc = " either of these is acceptable:"]
#[doc = ""]
#[doc = " @code"]
#[doc = " if (!vnc_Logger_createFileLogger(\"logfile.txt\"))"]
#[doc = "     handleError();"]
#[doc = " @endcode"]
#[doc = ""]
#[doc = " or:"]
#[doc = " @code"]
#[doc = " if (vnc_Logger_createFileLogger(\"logfile.txt\") != vnc_success)"]
#[doc = "     handleError();"]
#[doc = " @endcode"]
#[doc = ""]
pub type vnc_status_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Connection {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_ConnectionHandler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_AnnotationManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_MessagingManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DisplayManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DataBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Server {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_Viewer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_PixelFormat {
    _unused: [u8; 0],
}
pub type vnc_assert_int8_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int16_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int32_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_int64_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint8_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint16_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint31_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint32_t = [::std::os::raw::c_char; 1usize];
pub type vnc_assert_uint64_t = [::std::os::raw::c_char; 1usize];
pub const vnc_DummyEnum_vnc_DummyEnum1: vnc_DummyEnum = 0;
pub const vnc_DummyEnum_vnc_DummyEnum2: vnc_DummyEnum = 1;
pub type vnc_DummyEnum = ::std::os::raw::c_uint;
pub type vnc_assert_DummyEnum = [::std::os::raw::c_char; 1usize];
pub type VncAssertionHandler =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DirectTcpListener {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DirectTcpConnector {
    _unused: [u8; 0],
}
#[doc = " Callback for filtering incoming TCP connections."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnc_DirectTcpListener_Callback {
    #[doc = " Notification to provide address-based filtering of incoming connections."]
    #[doc = " This callback is optional."]
    #[doc = ""]
    #[doc = " @param listener The listening object that performed this callback."]
    #[doc = " @param ipAddress The IP address of the remote end that is attempting to"]
    #[doc = "     make a connection. The address is presented in a human-readable form"]
    #[doc = "     such as 122.16.224.1 (IPv4) and 2001:dc8:0:1534:0:867:6:1 (IPv6)"]
    #[doc = " @param port The port on which a connection is being attempted."]
    #[doc = ""]
    #[doc = " @return #vnc_true to allow the connection, or #vnc_false to deny, in which"]
    #[doc = "     case the connection will be closed."]
    #[doc = ""]
    #[doc = " @since 1.2"]
    pub filterConnection: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            listener: *mut vnc_DirectTcpListener,
            ipAddress: *const ::std::os::raw::c_char,
            port: ::std::os::raw::c_int,
        ) -> vnc_bool_t,
    >,
}
#[test]
fn bindgen_test_layout_vnc_DirectTcpListener_Callback() {
    assert_eq!(
        ::std::mem::size_of::<vnc_DirectTcpListener_Callback>(),
        8usize,
        concat!("Size of: ", stringify!(vnc_DirectTcpListener_Callback))
    );
    assert_eq!(
        ::std::mem::align_of::<vnc_DirectTcpListener_Callback>(),
        8usize,
        concat!("Alignment of ", stringify!(vnc_DirectTcpListener_Callback))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vnc_DirectTcpListener_Callback>())).filterConnection as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vnc_DirectTcpListener_Callback),
            "::",
            stringify!(filterConnection)
        )
    );
}

extern "C" {
    #[doc = " Begins an outgoing TCP connection to the given hostname or IP address.  The"]
    #[doc = " connection will be handled by the supplied @p connectionHandler."]
    #[doc = ""]
    #[doc = " The connection shall be via direct TCP unless a preceding call was made to"]
    #[doc = " @ref vnc_DirectTcpConnector_setProxySettings to result in connections being"]
    #[doc = " made via a proxy server."]
    #[doc = ""]
    #[doc = " Connection errors are notified using the server or viewer's callbacks"]
    #[doc = " (depending on the type of the connection handler used). This includes errors"]
    #[doc = " arising when resolving a specified hostname."]
    #[doc = ""]
    #[doc = " @param connector The TCP connector that is to begin the connection."]
    #[doc = " @param hostOrIpAddress The DNS hostname or IP address to connect to."]
    #[doc = " @param port The port number to connect to. Note: The default port for VNC"]
    #[doc = "     connections can be obtained using @ref VNC_DIRECT_TCP_DEFAULT_PORT"]
    #[doc = " @param connectionHandler The object (a Viewer or a Server) to handle the"]
    #[doc = "     connection."]
    #[doc = ""]
    #[doc = " @return #vnc_success is returned on success or #vnc_failure in the case of"]
    #[doc = "     an error, in which case vnc_getLastError() can be used to get the error"]
    #[doc = "     code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     @p port is invalid, or"]
    #[doc = "     @p connectionHandler is a null pointer"]
    #[doc = ""]
    #[doc = " @since 1.2"]
    pub fn vnc_DirectTcpConnector_connect(
        connector: *mut vnc_DirectTcpConnector,
        hostOrIpAddress: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_int,
        connectionHandler: *mut vnc_ConnectionHandler,
    ) -> vnc_status_t;
    #[doc = " Destroys the TCP Connector."]
    #[doc = ""]
    #[doc = " @param connector The TCP connector to destroy."]
    #[doc = ""]
    #[doc = " @since 1.2"]
    pub fn vnc_DirectTcpConnector_destroy(connector: *mut vnc_DirectTcpConnector);
    #[doc = " Set proxy server settings for this TCP Connector. The settings are adopted"]
    #[doc = " for all subsequent outgoing connections for this connector."]
    #[doc = " The proxy settings can be either the system configured settings or as"]
    #[doc = " specified in a supplied settings string."]
    #[doc = " If the proxy server requires authentication then full user credentials"]
    #[doc = " (i.e. username and password) must be configured."]
    #[doc = " Any connection error arising from the proxy settings is reported when an"]
    #[doc = " outgoing connection is attempted, see @ref vnc_DirectTcpConnector_connect"]
    #[doc = ""]
    #[doc = " @param connector The TCP connector that will employ the proxy settings"]
    #[doc = " @param systemProxy Set this to #vnc_true to employ the currently"]
    #[doc = "     configured system proxy settings. When set to #vnc_false, @p proxyUrl is"]
    #[doc = "     used to specify the proxy settings."]
    #[doc = " @param proxyUrl A string specifying a proxy server, plus user credentials"]
    #[doc = "     where these are required by an authenticated proxy server."]
    #[doc = "     The format of the string is:  type://username:password@address::port"]
    #[doc = "     Type is either 'socks' or 'http'"]
    #[doc = "     Example: socks://fred:X$frÂ£4Pw@mySocks5Proxy.here.com::8888"]
    #[doc = "     If @p systemProxy is #vnc_false and the proxyUrl string is null or empty"]
    #[doc = "     then this is treated as a request to stop using a proxy server."]
    #[doc = ""]
    #[doc = " @return #vnc_success is returned on success or #vnc_failure in the case of"]
    #[doc = "     an error, in which case vnc_getLastError() can be used to get the error"]
    #[doc = "     code."]
    #[doc = ""]
    #[doc = " @retval InvalidArgument"]
    #[doc = "     @p proxyUrl does not conform to the required format (see above)"]
    #[doc = ""]
    #[doc = " @since 1.2"]
    pub fn vnc_DirectTcpConnector_setProxySettings(
        connector: *mut vnc_DirectTcpConnector,
        systemProxy: vnc_bool_t,
        proxyUrl: *const ::std::os::raw::c_char,
    ) -> vnc_status_t;
    #[doc = " Creates a new TCP Connector which is used to make outgoing connections"]
    #[doc = "     to TCP listeners."]
    #[doc = ""]
    #[doc = " @return Returns a new TCP Connector on success, or NULL in the case of an"]
    #[doc = "     error, in which case vnc_getLastError() can be used to get the error"]
    #[doc = "     code."]
    #[doc = ""]
    #[doc = " @retval NotEnabled"]
    #[doc = "     The SDK does not have the Direct TCP add-on enabled"]
    #[doc = ""]
    #[doc = " @since 1.2"]
    pub fn vnc_DirectTcpConnector_create() -> *mut vnc_DirectTcpConnector;
    #[doc = " Destroys the TCP listener.  Any ongoing connections are not affected, but"]
    #[doc = " new connections will not be accepted."]
    #[doc = ""]
    #[doc = " @param listener The TCP listener to destroy."]
    #[doc = ""]
    #[doc = " @since 1.2"]
    pub fn vnc_DirectTcpListener_destroy(listener: *mut vnc_DirectTcpListener);
    #[doc = " Begin listening for incoming TCP connections on the given port (IPv4 and"]
    #[doc = " IPv6).  To stop listening, destroy the TCP listener."]
    #[doc = ""]
    #[doc = " @param port The port number to listen on."]
    #[doc = " @param addressList A comma-separated list of addresses to listen on. If"]
    #[doc = "     empty or null then listening starts on all addresses."]
    #[doc = " @param connectionHandler The object which shall handle incoming connections"]
    #[doc = "     (if not rejected by the filter function).  It is either a server or a"]
    #[doc = "     viewer.  It must be destroyed after the TCP listener."]
    #[doc = " @param callback An optional callback to filter incoming connections."]
    #[doc = " @param userData An optional pointer to user data."]
    #[doc = ""]
    #[doc = " @return Returns a new TCP listener on success, or NULL in the case of an"]
    #[doc = "     error, in which case vnc_getLastError() can be used to get the error"]
    #[doc = "     code."]
    #[doc = ""]
    #[doc = " @retval AddressError"]
    #[doc = "     There was an error listening on the specified address"]
    #[doc = " @retval NotEnabled"]
    #[doc = "     The SDK does not have the Direct TCP add-on enabled"]
    #[doc = ""]
    #[doc = " @since 1.2"]
    pub fn vnc_DirectTcpListener_create(
        port: ::std::os::raw::c_int,
        addressList: *const ::std::os::raw::c_char,
        connectionHandler: *mut vnc_ConnectionHandler,
        callback: *const vnc_DirectTcpListener_Callback,
        userData: *mut ::std::os::raw::c_void,
    ) -> *mut vnc_DirectTcpListener;
}
